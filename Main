# -*- coding: utf-8 -*- # Add this line for better UTF-8 support

import logging
import requests
from requests.auth import HTTPBasicAuth
from telegram import Update, InputFile, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from reportlab.lib.units import inch
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.pdfbase import pdfmetrics
import os
import time
from datetime import datetime, timedelta

# --- Constants and Config ---
# TOKEN = "YOUR_TELEGRAM_BOT_TOKEN" # Replace with your actual token
TOKEN = "8074321892:AAF6glPFFhVkWdS_FWVBYaMN4MkE8jsEjmY" # Your provided token

KISMET_URL = "http://localhost:2501"
KISMET_USERNAME = "kali"
KISMET_PASSWORD = "kali"


FONT_PATH = "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"
FONT_NAME = "DejaVu"

# --- Logging Setup ---
logging.basicConfig(
    filename="bot.log",
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- Global Variables ---
ssid_history = {}

# --- Alert Descriptions Dictionary ---
ALERT_DESCRIPTIONS = {
    "ADHOCCONFLICT": "Xung ƒë·ªôt m·∫°ng Ad-Hoc: Ph√°t hi·ªán thi·∫øt b·ªã c·ªë g·∫Øng tham gia/t·∫°o m·∫°ng ad-hoc khi kh√¥ng ƒë∆∞·ª£c ph√©p ho·∫∑c g√¢y xung ƒë·ªôt.",
    "ADVCRYPTCHANGE": "Thay ƒë·ªïi m√£ h√≥a n√¢ng cao: Ph√°t hi·ªán thay ƒë·ªïi ph∆∞∆°ng th·ª©c m√£ h√≥a tr√™n AP/m·∫°ng. C√≥ th·ªÉ l√† t·∫•n c√¥ng (downgrade) ho·∫∑c c·∫•u h√¨nh sai.",
    "AIRJACKSSID": "SSID c·ªßa AirJack: Ph√°t hi·ªán AP c√≥ th·ªÉ gi·∫£ m·∫°o s·ª≠ d·ª•ng SSID li√™n quan ƒë·∫øn c√¥ng c·ª• t·∫•n c√¥ng AirJack.",
    "APSPOOF": "Gi·∫£ m·∫°o AP: Ph√°t hi·ªán thi·∫øt b·ªã gi·∫£ m·∫°o ƒë·ªãa ch·ªâ MAC c·ªßa AP h·ª£p ph√°p ƒë·ªÉ l·ª´a ng∆∞·ªùi d√πng k·∫øt n·ªëi.",
    "BCASTDISCON": "Ng·∫Øt k·∫øt n·ªëi Broadcast: Ph√°t hi·ªán l∆∞·ª£ng l·ªõn khung tin ng·∫Øt k·∫øt n·ªëi/deauthentication g·ª≠i ƒë·∫øn ƒë·ªãa ch·ªâ broadcast (t·∫•n c√¥ng DoS).",
    "BCOM11KCHAN": "K√™nh Broadcom 802.11k: C·∫£nh b√°o li√™n quan ƒë·∫øn x·ª≠ l√Ω k√™nh 802.11k tr√™n thi·∫øt b·ªã Broadcom, c√≥ th·ªÉ ch·ªâ ra ho·∫°t ƒë·ªông kh√¥ng mong mu·ªën.",
    "BEACONRATE": "T·ªëc ƒë·ªô Beacon: T·ªëc ƒë·ªô ph√°t beacon t·ª´ AP b·∫•t th∆∞·ªùng (qu√° nhanh/ch·∫≠m). C√≥ th·ªÉ do AP gi·∫£ m·∫°o/l·ªói.",
    "BSSTIMESTAMP": "D·∫•u th·ªùi gian BSS: D·∫•u th·ªùi gian (timestamp) trong beacon kh√¥ng nh·∫•t qu√°n ho·∫∑c reset b·∫•t th∆∞·ªùng. C√≥ th·ªÉ do AP gi·∫£ m·∫°o/t·∫•n c√¥ng replay.",
    "CHANCHANGE": "Thay ƒë·ªïi k√™nh: AP thay ƒë·ªïi k√™nh ho·∫°t ƒë·ªông b·∫•t th∆∞·ªùng/th∆∞·ªùng xuy√™n. C√≥ th·ªÉ g√¢y gi√°n ƒëo·∫°n ho·∫∑c l√† d·∫•u hi·ªáu s·ª± c·ªë.",
    "CRYPTODROP": "M·∫•t g√≥i m√£ h√≥a: Ph√°t hi·ªán m·∫•t g√≥i d·ªØ li·ªáu m√£ h√≥a gi·ªØa AP v√† client. C√≥ th·ªÉ do nhi·ªÖu ho·∫∑c t·∫•n c√¥ng.",
    "DEAUTHFLOOD": "T·∫•n c√¥ng Deauthentication Flood: Ph√°t hi·ªán l∆∞·ª£ng l·ªõn khung deauthentication g·ª≠i ƒë·∫øn client/AP (t·∫•n c√¥ng DoS).",
    "DEAUTHCODEINVALID": "M√£ Deauthentication kh√¥ng h·ª£p l·ªá: Khung deauthentication ch·ª©a m√£ l√Ω do (reason code) kh√¥ng h·ª£p l·ªá. Th∆∞·ªùng do c√¥ng c·ª• t·∫•n c√¥ng/l·ªói.",
    "DHCPNAMECHANGE": "Thay ƒë·ªïi t√™n m√°y DHCP: Client thay ƒë·ªïi t√™n m√°y (hostname) gi·ªØa c√°c l·∫ßn y√™u c·∫ßu DHCP. C√≥ th·ªÉ b√¨nh th∆∞·ªùng ho·∫∑c b·∫•t th∆∞·ªùng.",
    "DHCPOSCHANGE": "Thay ƒë·ªïi h·ªá ƒëi·ªÅu h√†nh DHCP: Client b√°o c√°o HƒêH kh√°c nhau trong c√°c y√™u c·∫ßu DHCP. C√≥ th·ªÉ do thay th·∫ø thi·∫øt b·ªã/c√†i l·∫°i/gi·∫£ m·∫°o.",
    "DHCPCLIENTID": "ID Client DHCP: B·∫•t th∆∞·ªùng li√™n quan ƒë·∫øn ƒë·ªãnh danh client trong y√™u c·∫ßu DHCP (d√πng chung ID, thay ƒë·ªïi li√™n t·ª•c).",
    "DHCPCONFLICT": "Xung ƒë·ªôt DHCP: Ph√°t hi·ªán xung ƒë·ªôt ƒë·ªãa ch·ªâ IP do DHCP c·∫•p. C√≥ th·ªÉ do c·∫•u h√¨nh sai/nhi·ªÅu m√°y ch·ªß DHCP/l·ªói m√°y ch·ªß.",
    "DISASSOCTRAFFIC": "L∆∞u l∆∞·ª£ng Disassociation: Ph√°t hi·ªán l∆∞·ª£ng l·ªõn khung disassociation. N·∫øu b·∫•t th∆∞·ªùng, c√≥ th·ªÉ l√† t·∫•n c√¥ng DoS.",
    "DISCONCODEINVALID": "M√£ Disconnect kh√¥ng h·ª£p l·ªá: Khung disassociation ch·ª©a m√£ l√Ω do (reason code) kh√¥ng h·ª£p l·ªá. T∆∞∆°ng t·ª± DEAUTHCODEINVALID.",
    "DOT11D": "802.11d: Ph√°t hi·ªán v·∫•n ƒë·ªÅ v·ªõi th√¥ng tin v√πng (regulatory domain) theo chu·∫©n 802.11d. C√≥ th·ªÉ do AP gi·∫£ m·∫°o/c·∫•u h√¨nh sai.",
    "FORMATSTRING": "Chu·ªói ƒë·ªãnh d·∫°ng: Ph√°t hi·ªán chu·ªói k√Ω t·ª± gi·ªëng ƒë·ªãnh d·∫°ng chu·ªói (format string) trong g√≥i tin (nh∆∞ SSID). C√≥ th·ªÉ l√† t·∫•n c√¥ng khai th√°c l·ªó h·ªïng.",
    "KARMAOUI": "OUI KARMA: Ph√°t hi·ªán MAC c√≥ OUI li√™n quan ƒë·∫øn c√¥ng c·ª• t·∫•n c√¥ng KARMA (k·ªπ thu·∫≠t Evil Twin n√¢ng cao).",
    "LUCENTTEST": "Lucent Test (C≈©): C·∫£nh b√°o c≈© li√™n quan ƒë·∫øn th·ª≠ nghi·ªám/l·ªó h·ªïng tr√™n thi·∫øt b·ªã Lucent/Orinoco c≈©. Th∆∞·ªùng b·ªã v√¥ hi·ªáu h√≥a.",
    "LONGSSID": "SSID d√†i: AP qu·∫£ng b√° SSID d√†i h∆°n gi·ªõi h·∫°n (32 k√Ω t·ª±). C√≥ th·ªÉ l√† t·∫•n c√¥ng tr√†n b·ªô ƒë·ªám (buffer overflow) client.",
    "MSFBCOMSSID": "SSID Broadcom Metasploit: Ph√°t hi·ªán SSID d√πng b·ªüi module Metasploit nh·∫Øm v√†o l·ªó h·ªïng thi·∫øt b·ªã Broadcom.",
    "MSFDLINKRATE": "T·ªëc ƒë·ªô D-Link Metasploit: Ph√°t hi·ªán t·ªëc ƒë·ªô d·ªØ li·ªáu b·∫•t th∆∞·ªùng li√™n quan ƒë·∫øn t·∫•n c√¥ng Metasploit nh·∫Øm v√†o D-Link.",
    "MSFNETGEARBEACON": "Beacon Netgear Metasploit: Ph√°t hi·ªán beacon gi·ªëng nh∆∞ t·∫°o b·ªüi module Metasploit nh·∫Øm v√†o Netgear.",
    "MALFORMMGMT": "Khung qu·∫£n l√Ω l·ªói ƒë·ªãnh d·∫°ng: Khung qu·∫£n l√Ω Wi-Fi (beacon, probe, auth,...) c√≥ c·∫•u tr√∫c kh√¥ng ƒë√∫ng chu·∫©n/l·ªói. Do l·ªói ph·∫ßn m·ªÅm/nhi·ªÖu/t·∫•n c√¥ng.",
    "NETSTUMBLER": "NetStumbler (C≈©): Ph√°t hi·ªán ho·∫°t ƒë·ªông c·ªßa c√¥ng c·ª• qu√©t m·∫°ng NetStumbler. √çt gi√° tr·ªã hi·ªán nay. Th∆∞·ªùng b·ªã v√¥ hi·ªáu h√≥a.",
    "NOCLIENTMFP": "Client kh√¥ng h·ªó tr·ª£ MFP: Client k·∫øt n·ªëi m·∫°ng y√™u c·∫ßu MFP (802.11w) nh∆∞ng kh√¥ng h·ªó tr·ª£, l√†m gi·∫£m b·∫£o m·∫≠t (khung qu·∫£n l√Ω kh√¥ng ƒë∆∞·ª£c b·∫£o v·ªá).",
    "NONCEDEGRADE": "Gi·∫£m ch·∫•t l∆∞·ª£ng Nonce: S·ª≠ d·ª•ng nonce (s·ªë ng·∫´u nhi√™n d√πng m·ªôt l·∫ßn trong WPA/WPA2) y·∫øu/d·ªÖ ƒëo√°n. L√†m suy y·∫øu m√£ h√≥a. (C√≥ th·ªÉ b·ªã v√¥ hi·ªáu h√≥a).",
    "NONCEREUSE": "T√°i s·ª≠ d·ª•ng Nonce: T√°i s·ª≠ d·ª•ng nonce trong c√°c phi√™n m√£ h√≥a kh√°c nhau. L·ªó h·ªïng nghi√™m tr·ªçng, cho ph√©p gi·∫£i m√£/gi·∫£ m·∫°o g√≥i tin. (C√≥ th·ªÉ b·ªã v√¥ hi·ªáu h√≥a).",
    "NULLPROBERESP": "Ph·∫£n h·ªìi Probe r·ªóng: AP g·ª≠i ph·∫£n h·ªìi probe kh√¥ng ch·ª©a SSID. H√†nh vi kh√¥ng chu·∫©n, c√≥ th·ªÉ l√† m·∫°ng ·∫©n ho·∫∑c AP b·∫•t th∆∞·ªùng.",
    "OVERPOWERED": "C√¥ng su·∫•t qu√° m·∫°nh: Thi·∫øt b·ªã Wi-Fi ph√°t s√≥ng v·ªõi c√¥ng su·∫•t v∆∞·ª£t m·ª©c cho ph√©p. G√¢y nhi·ªÖu ho·∫∑c l√† d·∫•u hi·ªáu thi·∫øt b·ªã gi·∫£ m·∫°o. (C√≥ th·ªÉ b·ªã v√¥ hi·ªáu h√≥a).",
    "PROBECHAN": "K√™nh Probe: Client g·ª≠i probe request tr√™n k√™nh kh√¥ng mong ƒë·ª£i (kh√¥ng ph√©p/kh√¥ng ho·∫°t ƒë·ªông). C√≥ th·ªÉ l√† qu√©t m·∫°ng ch·ªß ƒë·ªông.",
    "QCOMEXTENDED": "M·ªü r·ªông Qualcomm: Ph√°t hi·ªán IE (Information Elements) ƒë·ªôc quy·ªÅn/m·ªü r·ªông c·ªßa Qualcomm b·∫•t th∆∞·ªùng. C√≥ th·ªÉ li√™n quan ƒë·∫øn l·ªó h·ªïng. (C√≥ th·ªÉ b·ªã v√¥ hi·ªáu h√≥a).",
    "RSNLOOP": "V√≤ng l·∫∑p RSN: L·∫∑p l·∫°i b·∫•t th∆∞·ªùng trong qu√° tr√¨nh b·∫Øt tay 4 b∆∞·ªõc WPA/WPA2. C√≥ th·ªÉ l√† t·∫•n c√¥ng DoS ho·∫∑c l·ªói t∆∞∆°ng th√≠ch.",
    "RTL8195VD1406": "L·ªó h·ªïng Realtek RTL8195 VD1406: D·∫•u hi·ªáu khai th√°c l·ªó h·ªïng b·∫£o m·∫≠t c·ª• th·ªÉ tr√™n thi·∫øt b·ªã d√πng chip Realtek RTL8195.",
    "RTLWIFIP2P": "Wi-Fi Direct Realtek P2P: Ho·∫°t ƒë·ªông Wi-Fi Direct (P2P) b·∫•t th∆∞·ªùng ho·∫∑c khai th√°c l·ªó h·ªïng P2P tr√™n thi·∫øt b·ªã Realtek.",
    "VDOO202027301": "L·ªó h·ªïng VDOO 2020-27301: D·∫•u hi·ªáu khai th√°c l·ªó h·ªïng CVE-2020-27301 (tra c·ª©u CVE ƒë·ªÉ bi·∫øt chi ti·∫øt, th∆∞·ªùng l√† IoT/camera).",
    "VDOO202027302": "L·ªó h·ªïng VDOO 2020-27302: T∆∞∆°ng t·ª±, nh∆∞ng li√™n quan ƒë·∫øn CVE-2020-27302.",
    "WPSBRUTE": "T·∫•n c√¥ng Brute-force WPS: D·∫•u hi·ªáu t·∫•n c√¥ng brute-force d√≤ m√£ PIN WPS (c√≥ l·ªó h·ªïng nghi√™m tr·ªçng).",
    "WMMOVERFLOW": "Tr√†n b·ªô ƒë·ªám WMM: Khung tin WMM (∆∞u ti√™n ƒëa ph∆∞∆°ng ti·ªán) c√≥ k√≠ch th∆∞·ªõc/c·∫•u tr√∫c b·∫•t th∆∞·ªùng. C√≥ th·ªÉ l√† khai th√°c l·ªó h·ªïng tr√†n b·ªô ƒë·ªám.",
    "WMMTSPEC": "TSPEC WMM: Khung TSPEC (y√™u c·∫ßu QoS) trong WMM ch·ª©a gi√° tr·ªã kh√¥ng h·ª£p l·ªá/b·∫•t th∆∞·ªùng. C√≥ th·ªÉ l√† t·∫•n c√¥ng DoS ho·∫∑c khai th√°c l·ªó h·ªïng.",
}

# --- Font Registration ---
def register_font():
    """ƒêƒÉng k√Ω font ch·ªØ n·∫øu t·ªìn t·∫°i."""
    if os.path.exists(FONT_PATH):
        try:
            pdfmetrics.registerFont(TTFont(FONT_NAME, FONT_PATH))
            logger.info(f"ƒê√£ ƒëƒÉng k√Ω font th√†nh c√¥ng: {FONT_PATH}")
            return True
        except Exception as e:
            logger.error(f"L·ªói ƒëƒÉng k√Ω font {FONT_PATH}: {e}")
            return False
    else:
        logger.warning(f"Kh√¥ng t√¨m th·∫•y file font t·∫°i: {FONT_PATH}. Ch·ª©c nƒÉng PDF c√≥ th·ªÉ b·ªã ·∫£nh h∆∞·ªüng.")
        return False

FONT_REGISTERED = register_font()

# --- Kismet API Fetch Function ---
def fetch_kismet_data(endpoint):
    try:
        url = f"{KISMET_URL}{endpoint}"
        response = requests.get(url, auth=HTTPBasicAuth(KISMET_USERNAME, KISMET_PASSWORD), timeout=15)
        response.raise_for_status() # Raise HTTPError for bad responses (4xx or 5xx)

        content_type = response.headers.get("Content-Type", "")
        if "application/json" not in content_type:
            logger.error(f"Kismet endpoint {endpoint} kh√¥ng tr·∫£ v·ªÅ JSON. Content-Type: {content_type}")
            # Read the response text for better debugging, even if not JSON
            try:
                error_details = response.text[:500] # Limit error message size
            except Exception:
                error_details = "(Kh√¥ng th·ªÉ ƒë·ªçc n·ªôi dung ph·∫£n h·ªìi)"
            return None, f"‚ùå D·ªØ li·ªáu tr·∫£ v·ªÅ t·ª´ Kismet kh√¥ng h·ª£p l·ªá (kh√¥ng ph·∫£i JSON) cho endpoint: {endpoint}. N·ªôi dung: {error_details}"

        return response.json(), None

    except requests.exceptions.ConnectionError as e:
        logger.error(f"L·ªói k·∫øt n·ªëi Kismet: {e}")
        return None, f"‚ùå L·ªói k·∫øt n·ªëi Kismet: Kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi {KISMET_URL}. Vui l√≤ng ki·ªÉm tra Kismet c√≥ ƒëang ch·∫°y v√† URL/port ƒë√∫ng kh√¥ng."
    except requests.exceptions.Timeout:
        logger.error(f"L·ªói Kismet Timeout cho endpoint: {endpoint}")
        return None, f"‚ùå L·ªói Kismet Timeout: Y√™u c·∫ßu t·ªõi {endpoint} m·∫•t qu√° nhi·ªÅu th·ªùi gian."
    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 401:
            logger.error("L·ªói x√°c th·ª±c Kismet (401).")
            return None, "‚ùå L·ªói x√°c th·ª±c Kismet (401): Vui l√≤ng ki·ªÉm tra Username/Password."
        # Log the response body for other HTTP errors if possible
        error_details = ""
        try:
            error_details = e.response.text[:500] # Limit error message size
        except Exception:
            error_details = "(Kh√¥ng th·ªÉ ƒë·ªçc n·ªôi dung l·ªói)"
        logger.error(f"L·ªói HTTP t·ª´ Kismet ({e.response.status_code}) cho endpoint {endpoint}: {e}. Chi ti·∫øt: {error_details}")
        return None, f"‚ùå L·ªói HTTP t·ª´ Kismet ({e.response.status_code}) cho endpoint: {endpoint}. Chi ti·∫øt: {error_details}"
    except requests.exceptions.RequestException as e:
        logger.error(f"L·ªói y√™u c·∫ßu Kismet kh√¥ng x√°c ƒë·ªãnh: {e}")
        return None, f"‚ùå L·ªói y√™u c·∫ßu Kismet kh√¥ng x√°c ƒë·ªãnh: {e}"
    except ValueError as e: # L·ªói khi parse JSON
        logger.error(f"L·ªói parse JSON t·ª´ Kismet endpoint {endpoint}: {e}")
        # Try to get the raw text that failed parsing
        raw_text = ""
        if 'response' in locals() and hasattr(response, 'text'):
             raw_text = response.text[:500] # Limit raw text size
        return None, f"‚ùå D·ªØ li·ªáu tr·∫£ v·ªÅ t·ª´ Kismet kh√¥ng h·ª£p l·ªá (l·ªói parse JSON) cho endpoint: {endpoint}. Raw data (n·∫øu c√≥): {raw_text}"

# --- Utility Functions ---
def split_message(text, chunk_size=4000):
    """Chia nh·ªè tin nh·∫Øn n·∫øu v∆∞·ª£t qu√° gi·ªõi h·∫°n Telegram."""
    if not isinstance(text, str):
       text = str(text)
    for i in range(0, len(text), chunk_size):
        yield text[i:i + chunk_size]

# --- Data Fetching Functions (get_all_ap, get_ap_monitor_data, etc.) ---
async def get_all_ap():
    """L·∫•y danh s√°ch APs v√† ƒë·ªãnh d·∫°ng ch√∫ng th√†nh list c√°c string."""
    data, error = fetch_kismet_data("/devices/views/phydot11_accesspoints/devices.json")
    if error:
        return [error]

    if not data or not isinstance(data, list):
         logger.warning("D·ªØ li·ªáu APs tr·∫£ v·ªÅ kh√¥ng ph·∫£i list ho·∫∑c r·ªóng.")
         return ["‚ÑπÔ∏è Kh√¥ng nh·∫≠n ƒë∆∞·ª£c d·ªØ li·ªáu AP h·ª£p l·ªá t·ª´ Kismet ho·∫∑c kh√¥ng c√≥ AP n√†o."]

    ap_list = []
    for ap in data:
        if ap.get("kismet.device.base.type") == "Wi-Fi AP":
            ssid = ap.get("kismet.device.base.commonname", "·∫®n/Kh√¥ng t√™n")
            bssid = ap.get("kismet.device.base.macaddr", "Unknown BSSID")
            encryption=ap.get("kismet.device.base.crypt","Unknown_Encryption")

            signal_info = ap.get("kismet.common.signal", {})
            signal_dbm = signal_info.get("last_signal_dbm", "N/A")
            channel = ap.get("kismet.phy.dot11.channel", "N/A") # L·∫•y k√™nh

            ap_list.append(
                f"üì° **SSID:** `{ssid}`\n"
                f"üîç **BSSID:** `{bssid.upper()}`\n"
                f"üîí **B·∫£o m·∫≠t:** `{encryption}`\n"
                f"üì∂ **K√™nh:** `{channel}` | **T√≠n hi·ªáu:** `{signal_dbm} dBm`\n"
                f"„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è"
            )

    return ap_list if ap_list else ["‚úÖ Kh√¥ng t√¨m th·∫•y AP n√†o!"]

async def get_ap_monitor_data():
    """L·∫•y d·ªØ li·ªáu SSID v√† BSSID c·∫ßn thi·∫øt cho vi·ªác gi√°m s√°t."""
    data, error = fetch_kismet_data("/devices/views/phydot11_accesspoints/devices.json")
    if error:
        return None, error

    if not data or not isinstance(data, list):
         logger.warning("D·ªØ li·ªáu APs monitor tr·∫£ v·ªÅ kh√¥ng ph·∫£i list ho·∫∑c r·ªóng.")
         return [], None

    ap_pairs = []
    for ap in data:
        if ap.get("kismet.device.base.type") == "Wi-Fi AP":
            ssid = ap.get("kismet.device.base.commonname", "Unknown_SSID")
            bssid = ap.get("kismet.device.base.macaddr")
            if bssid:
               ap_pairs.append({"ssid": ssid, "bssid": bssid.lower()})

    return ap_pairs, None

async def monitor_ssid_changes():
    """Gi√°m s√°t s·ª± thay ƒë·ªïi SSID c·ªßa c√°c AP ƒë√£ bi·∫øt BSSID."""
    global ssid_history
    ap_pairs, error = await get_ap_monitor_data()

    if error:
        return [error] # Tr·∫£ v·ªÅ l·ªói

    if ap_pairs is None:
        return ["‚ùå Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu AP ƒë·ªÉ gi√°m s√°t."]

    rogue_aps = []

    current_bssid_map = {ap['bssid']: ap['ssid'] for ap in ap_pairs}

    for bssid, current_ssid in current_bssid_map.items():
        if bssid not in ssid_history:
            # BSSID m·ªõi, ghi nh·∫≠n l·∫ßn ƒë·∫ßu
            ssid_history[bssid] = {current_ssid}
        elif current_ssid not in ssid_history[bssid]:
            # BSSID ƒë√£ bi·∫øt nh∆∞ng c√≥ SSID m·ªõi
            old_ssids = ssid_history[bssid]
            ssid_history[bssid].add(current_ssid) # Th√™m SSID m·ªõi v√†o l·ªãch s·ª≠
            rogue_aps.append(f"üö® **RAP Detected (SSID Change):**\n"
                             f"   BSSID: `{bssid.upper()}`\n"
                             f"   SSID M·ªõi: `{current_ssid}`\n"
                             f"   SSIDs Tr∆∞·ªõc ƒë√≥: `{', '.join(old_ssids)}`")
            logger.warning(f"RAP Ph√°t hi·ªán (SSID Change): BSSID: {bssid}, SSID m·ªõi: {current_ssid}, SSIDs c≈©: {old_ssids}")
    return rogue_aps if rogue_aps else []

async def get_alerts(limit=5):
    """L·∫•y danh s√°ch c·∫£nh b√°o t·ª´ Kismet (gi·ªõi h·∫°n s·ªë l∆∞·ª£ng)."""
    data, error = fetch_kismet_data("/alerts/all_alerts.json")
    if error:
        return [error]

    if not data or not isinstance(data, list):
        return ["‚úÖ Kh√¥ng c√≥ c·∫£nh b√°o n√†o t·ª´ Kismet ho·∫∑c d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá!"]
    try:
        # Handle potential None or 0 timestamp values during sorting
        def get_timestamp(alert):
            ts = alert.get('kismet.alert.timestamp', 0) or alert.get('kismet.alert.sec', 0)
            return ts if ts else 0 # Return 0 if both are missing or None/0

        sorted_alerts = sorted(data, key=get_timestamp, reverse=True)
    except Exception as e:
        logger.warning(f"Kh√¥ng th·ªÉ s·∫Øp x·∫øp c·∫£nh b√°o theo timestamp: {e}. S·ª≠ d·ª•ng th·ª© t·ª± g·ªëc.")
        sorted_alerts = data

    latest_alerts = sorted_alerts[:limit]
    alert_list = []
    for alert in latest_alerts:
        header = alert.get("kismet.alert.header", "N/A")
        text = alert.get("kismet.alert.text", "Kh√¥ng c√≥ m√¥ t·∫£")

        # L·∫•y timestamp v√† ƒë·ªãnh d·∫°ng
        timestamp_sec = alert.get('kismet.alert.timestamp') or alert.get('kismet.alert.sec')
        if timestamp_sec:
            try:
                # Handle potential large timestamp values (milliseconds vs seconds)
                if timestamp_sec > time.time() * 2: # Basic check if it looks like ms
                    timestamp_sec /= 1000
                dt_object = datetime.fromtimestamp(timestamp_sec)
                timestamp_str = dt_object.strftime("%Y-%m-%d %H:%M:%S")
            except (ValueError, OSError, TypeError) as ts_err:
                 logger.warning(f"L·ªói ƒë·ªãnh d·∫°ng timestamp '{timestamp_sec}': {ts_err}")
                 timestamp_str = f"Invalid ({timestamp_sec})"
        else:
            timestamp_str = "N/A"

        alert_list.append(f"üîî **{header}**\n"
                          f"   üìå {text}\n"
                          f"   üïí {timestamp_str}\n"
                          f"{'-'*30}")

    return alert_list if alert_list else ["‚úÖ Kh√¥ng c√≥ c·∫£nh b√°o n√†o trong gi·ªõi h·∫°n y√™u c·∫ßu."]


async def get_clients_by_ap(ssid_filter):
    logger.info(f"B·∫Øt ƒë·∫ßu t√¨m client cho SSID: {ssid_filter}")
    target_bssid = None
    aps_data, aps_error = fetch_kismet_data("/devices/views/phydot11_accesspoints/devices.json")
    if aps_error:
        return [f"‚ùå L·ªói khi t√¨m BSSID cho SSID '{ssid_filter}': {aps_error}"]
    if not aps_data or not isinstance(aps_data, list):
        return [f"‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y AP n√†o ho·∫∑c d·ªØ li·ªáu AP kh√¥ng h·ª£p l·ªá ƒë·ªÉ t√¨m client cho SSID '{ssid_filter}'."]

    found_aps = []
    for ap in aps_data:
        if ap.get("kismet.device.base.type") == "Wi-Fi AP":
             ap_ssid = ap.get("kismet.device.base.commonname", "")
             # Case-insensitive and strip whitespace comparison
             if ap_ssid.strip().lower() == ssid_filter.strip().lower():
                  bssid = ap.get("kismet.device.base.macaddr")
                  if bssid:
                      found_aps.append(bssid.lower())

    if not found_aps:
        return [f"‚úÖ Kh√¥ng t√¨m th·∫•y AP n√†o ƒëang ho·∫°t ƒë·ªông v·ªõi SSID: **{ssid_filter}**"]
    if len(found_aps) > 1:
        logger.warning(f"T√¨m th·∫•y nhi·ªÅu AP ({len(found_aps)}) v·ªõi SSID '{ssid_filter}'. S·ª≠ d·ª•ng BSSID ƒë·∫ßu ti√™n: {found_aps[0].upper()}")
        # Optionally inform the user:
        # await update.message.reply_text(f"‚ÑπÔ∏è T√¨m th·∫•y nhi·ªÅu AP kh·ªõp. Hi·ªÉn th·ªã client cho BSSID: `{found_aps[0].upper()}`", parse_mode="Markdown")

    target_bssid = found_aps[0] # L·∫•y BSSID ƒë·∫ßu ti√™n t√¨m ƒë∆∞·ª£c
    logger.info(f"T√¨m th·∫•y BSSID {target_bssid.upper()} cho SSID '{ssid_filter}'")

    clients_list = []
    # Endpoint preference: by-mac first, then phy-IEEE802.11 view
    all_dev_data, dev_error = fetch_kismet_data("/devices/by-mac/*/device.json")
    if dev_error or not isinstance(all_dev_data, list): # Check for error or invalid data type
         logger.warning(f"Kh√¥ng th·ªÉ d√πng /devices/by-mac/*/device.json (L·ªói: {dev_error}), th·ª≠ /devices/views/phy-IEEE802.11/devices.json")
         all_dev_data, dev_error = fetch_kismet_data("/devices/views/phy-IEEE802.11/devices.json")
         if dev_error:
              return [f"‚ùå L·ªói khi l·∫•y danh s√°ch thi·∫øt b·ªã: {dev_error}"]

    if not all_dev_data or not isinstance(all_dev_data, list):
        return [f"‚ÑπÔ∏è Kh√¥ng nh·∫≠n ƒë∆∞·ª£c d·ªØ li·ªáu thi·∫øt b·ªã h·ª£p l·ªá t·ª´ Kismet ƒë·ªÉ t√¨m client cho SSID '{ssid_filter}'."]

    for device in all_dev_data:
        # Check if it's a Wi-Fi Client
        if device.get("kismet.device.base.type") != "Wi-Fi Client":
            continue

        # Find the BSSID it's associated with (handle different Kismet versions/structures)
        last_bssid = None
        dot11_device_data = device.get("dot11.device")
        if dot11_device_data and isinstance(dot11_device_data, dict):
            last_bssid = dot11_device_data.get("dot11.device.last_bssid")

        # Fallback field (adjust if needed based on your Kismet version)
        if not last_bssid:
             last_bssid = device.get("kismet.wireless.client. BSSID") # Check field name carefully

        # Compare BSSIDs (case-insensitive)
        if last_bssid and last_bssid.lower() == target_bssid:
            mac_address = device.get("kismet.device.base.macaddr", "Unknown MAC")
            signal_info = device.get("kismet.common.signal", {})
            signal_dbm = signal_info.get("last_signal_dbm", "N/A")
            clients_list.append(f"üì± **MAC:** `{mac_address.upper()}` | **T√≠n hi·ªáu:** `{signal_dbm} dBm`")

    logger.info(f"T√¨m th·∫•y {len(clients_list)} client cho BSSID {target_bssid.upper()}")
    if not clients_list:
         return [f"‚úÖ Kh√¥ng t√¨m th·∫•y client n√†o ƒëang k·∫øt n·ªëi v√†o AP **{ssid_filter}** (BSSID: `{target_bssid.upper()}`)"]
    else:
        # Prepend the header message to the list
        header = f"üë• Client ƒëang k·∫øt n·ªëi v√†o **{ssid_filter}** (BSSID: `{target_bssid.upper()}`):"
        return [header] + clients_list

async def get_summary_data():
    """L·∫•y d·ªØ li·ªáu t√≥m t·∫Øt t·ª´ Kismet (APs, Clients, Alerts)."""
    summary = {
        "ap_count": 0,
        "client_count": 0,
        "new_alert_count": 0,
        "strongest_ap": None,
        "max_ap_signal": -1000, # Initialize with a very low value
        "strongest_client": None,
        "max_client_signal": -1000, # Initialize with a very low value
        "errors": []
    }
    start_time = time.time()
    logger.info("B·∫Øt ƒë·∫ßu l·∫•y d·ªØ li·ªáu t√≥m t·∫Øt...")

    # --- Fetch AP Data ---
    ap_data, ap_error = fetch_kismet_data("/devices/views/phydot11_accesspoints/devices.json")
    if ap_error:
        summary["errors"].append(f"L·ªói l·∫•y AP: {ap_error}")
        logger.error(f"Summary Error (AP): {ap_error}")
    elif ap_data and isinstance(ap_data, list):
        for ap in ap_data:
            if ap.get("kismet.device.base.type") == "Wi-Fi AP":
                summary["ap_count"] += 1
                try:
                    signal_dbm = ap.get("kismet.common.signal", {}).get("last_signal_dbm")
                    if signal_dbm is not None and isinstance(signal_dbm, (int, float)):
                       if signal_dbm > summary["max_ap_signal"]:
                            summary["max_ap_signal"] = signal_dbm
                            summary["strongest_ap"] = {
                                "ssid": ap.get("kismet.device.base.commonname", "N/A"),
                                "bssid": ap.get("kismet.device.base.macaddr", "N/A")
                            }
                except Exception as e:
                    logger.warning(f"Summary: Kh√¥ng th·ªÉ x·ª≠ l√Ω t√≠n hi·ªáu AP {ap.get('kismet.device.base.macaddr')}: {e}")
    else:
         logger.warning("Summary: D·ªØ li·ªáu AP kh√¥ng h·ª£p l·ªá ho·∫∑c r·ªóng.")


    # --- Fetch Client Data (Using a more reliable view) ---
    client_data, client_error = fetch_kismet_data("/devices/views/phy-IEEE802.11/devices.json")
    if client_error:
        summary["errors"].append(f"L·ªói l·∫•y Client: {client_error}")
        logger.error(f"Summary Error (Client): {client_error}")
    elif client_data and isinstance(client_data, list):
         for device in client_data:
             if device.get("kismet.device.base.type") == "Wi-Fi Client":
                summary["client_count"] += 1
                try:
                    signal_dbm = device.get("kismet.common.signal", {}).get("last_signal_dbm")
                    if signal_dbm is not None and isinstance(signal_dbm, (int, float)):
                        if signal_dbm > summary["max_client_signal"]:
                            summary["max_client_signal"] = signal_dbm
                            summary["strongest_client"] = {
                                "mac": device.get("kismet.device.base.macaddr", "N/A")
                            }
                except Exception as e:
                     logger.warning(f"Summary: Kh√¥ng th·ªÉ x·ª≠ l√Ω t√≠n hi·ªáu Client {device.get('kismet.device.base.macaddr')}: {e}")
    else:
        logger.warning("Summary: D·ªØ li·ªáu client kh√¥ng h·ª£p l·ªá ho·∫∑c r·ªóng.")


    # --- Fetch Alert Data ---
    alert_data, alert_error = fetch_kismet_data("/alerts/all_alerts.json")
    if alert_error:
        summary["errors"].append(f"L·ªói l·∫•y C·∫£nh b√°o: {alert_error}")
        logger.error(f"Summary Error (Alert): {alert_error}")
    elif alert_data and isinstance(alert_data, list):
        # Calculate timestamp 24 hours ago
        try:
            cutoff_timestamp = (datetime.now() - timedelta(hours=24)).timestamp()
        except Exception as time_err:
            logger.error(f"Summary: L·ªói t√≠nh to√°n cutoff timestamp: {time_err}")
            cutoff_timestamp = 0 # Default to counting all if error

        for alert in alert_data:
            try:
                 # Prefer 'timestamp', fallback to 'sec'
                 alert_timestamp = alert.get('kismet.alert.timestamp') or alert.get('kismet.alert.sec')
                 if alert_timestamp and isinstance(alert_timestamp, (int, float)):
                     # Handle potential millisecond timestamps
                     if alert_timestamp > time.time() * 2: # Basic check
                         alert_timestamp /= 1000
                     if alert_timestamp >= cutoff_timestamp:
                         summary["new_alert_count"] += 1
            except (ValueError, TypeError, OSError) as e: # Catch potential conversion errors
                 logger.warning(f"Summary: Kh√¥ng th·ªÉ x·ª≠ l√Ω timestamp c·∫£nh b√°o {alert.get('alert_key', 'N/A')}: {e}")
    else:
        logger.warning("Summary: D·ªØ li·ªáu c·∫£nh b√°o kh√¥ng h·ª£p l·ªá ho·∫∑c r·ªóng.")

    end_time = time.time()
    logger.info(f"Ho√†n th√†nh l·∫•y d·ªØ li·ªáu t√≥m t·∫Øt trong {end_time - start_time:.2f} gi√¢y.")
    return summary


# --- Telegram Command Handlers ---

async def start(update: Update, context: CallbackContext):
    """X·ª≠ l√Ω l·ªánh /start."""
    user_name = update.effective_user.first_name
    keyboard = [
        [KeyboardButton("/ap"), KeyboardButton("/summary")],
        [KeyboardButton("/alert"), KeyboardButton("/monitor")],
        [KeyboardButton("/appdf"), KeyboardButton("/help")],
        [KeyboardButton("T√¨m Client (nh·∫≠p /client SSID)")],
        [KeyboardButton("Gi·∫£i th√≠ch Alert (nh·∫≠p /type CODE)")], # Add button hint
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
    await update.message.reply_text(
        f"üëã Xin ch√†o {user_name}!\n"
        "T√¥i l√† Bot Kismet. S·ª≠ d·ª•ng c√°c n√∫t b√™n d∆∞·ªõi ho·∫∑c g√µ l·ªánh.\n"
        "G√µ /help ƒë·ªÉ xem m√¥ t·∫£ chi ti·∫øt c√°c l·ªánh.",
        reply_markup=reply_markup
    )

async def help_command(update: Update, context: CallbackContext):
    """Hi·ªÉn th·ªã danh s√°ch c√°c l·ªánh."""
    help_text = (
        "üìå **Danh s√°ch l·ªánh c√≥ s·∫µn:**\n\n"
        "`/start` - Hi·ªÉn th·ªã tin nh·∫Øn ch√†o m·ª´ng v√† b√†n ph√≠m l·ªánh.\n\n"
        "`/help` - Hi·ªÉn th·ªã danh s√°ch l·ªánh n√†y.\n\n"
        "`/ap` - üì° L·∫•y danh s√°ch Access Point (APs) ph√°t hi·ªán ƒë∆∞·ª£c.\n\n"
        "`/summary` - üìä Xem b√°o c√°o t√≥m t·∫Øt nhanh Kismet.\n\n"
        "`/alert` - üîî Xem 5 c·∫£nh b√°o Kismet g·∫ßn nh·∫•t.\n\n"
        "`/client <SSID>` - üë• Li·ªát k√™ client k·∫øt n·ªëi v√†o AP c√≥ SSID c·ª• th·ªÉ (vd: `/client MyWifi`).\n\n"
        "`/monitor` - üö® Ki·ªÉm tra AP ƒë√£ bi·∫øt thay ƒë·ªïi SSID (RAP).\n\n"
        "`/appdf` - üìÑ Xu·∫•t danh s√°ch AP hi·ªán t·∫°i th√†nh file PDF.\n\n"
        "`/type <ALERT_CODE>` - ‚ÑπÔ∏è Gi·∫£i th√≠ch √Ω nghƒ©a c·ªßa m·ªôt m√£ c·∫£nh b√°o Kismet c·ª• th·ªÉ (vd: `/type APSPOOF`).\n" # Added /type
        "\n_L∆∞u √Ω: M·ªôt s·ªë l·ªánh c√≥ th·ªÉ m·∫•t v√†i gi√¢y ƒë·ªÉ x·ª≠ l√Ω._"
    )
    # Send without the reply keyboard unless explicitly requested
    await update.message.reply_text(help_text, parse_mode="Markdown", reply_markup=None)


async def ap_command(update: Update, context: CallbackContext):
    """L·∫•y v√† g·ª≠i danh s√°ch APs."""
    await update.message.reply_text("üì° ƒêang l·∫•y danh s√°ch Access Points t·ª´ Kismet...")
    result = await get_all_ap()
    if result and isinstance(result, list) and result[0].startswith("‚ùå"):
         await update.message.reply_text(result[0]) # Send error message
    elif not result:
         await update.message.reply_text("‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y AP n√†o ho·∫∑c kh√¥ng c√≥ d·ªØ li·ªáu.")
    else:
        result_text = "\n\n".join(result)
        if not result_text.strip():
            await update.message.reply_text("‚úÖ Kh√¥ng t√¨m th·∫•y AP n√†o!")
        else:
            for part in split_message(result_text):
                await update.message.reply_text(part, parse_mode="Markdown")

async def appdf_command(update: Update, context: CallbackContext):
    """Xu·∫•t danh s√°ch APs th√†nh file PDF."""
    if not FONT_REGISTERED:
        await update.message.reply_text("‚ùå L·ªói: Kh√¥ng th·ªÉ t·∫°o PDF do font ch·ªØ ch∆∞a ƒë∆∞·ª£c ƒëƒÉng k√Ω ho·∫∑c kh√¥ng t√¨m th·∫•y. Vui l√≤ng ki·ªÉm tra c·∫•u h√¨nh `FONT_PATH` v√† c√†i ƒë·∫∑t font ch·ªØ.")
        return

    await update.message.reply_text("üìÑ ƒêang t·∫°o file PDF danh s√°ch Access Points...")

    ap_list_formatted = await get_all_ap()

    # Handle error case from get_all_ap()
    if not ap_list_formatted or (isinstance(ap_list_formatted, list) and ap_list_formatted[0].startswith("‚ùå")):
        error_msg = ap_list_formatted[0] if ap_list_formatted else "‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu AP ƒë·ªÉ xu·∫•t PDF."
        await update.message.reply_text(error_msg)
        return
    # Handle case where get_all_ap returns the "No APs found" message
    if isinstance(ap_list_formatted, list) and "Kh√¥ng t√¨m th·∫•y AP n√†o" in ap_list_formatted[0]:
         await update.message.reply_text("‚úÖ Kh√¥ng c√≥ AP n√†o ƒë·ªÉ xu·∫•t ra PDF.")
         return


    pdf_filename = f"kismet_aps_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"

    try:
        c = canvas.Canvas(pdf_filename, pagesize=letter)
        width, height = letter
        margin = 0.75 * inch
        text_width = width - 2 * margin
        current_y = height - margin

        # --- Header ---
        c.setFont(FONT_NAME, 16) # Slightly smaller header
        c.drawCentredString(width / 2.0, current_y, "B√°o c√°o Access Points - Kismet")
        current_y -= 25
        c.setFont(FONT_NAME, 10)
        c.drawString(margin, current_y, f"Ng√†y t·∫°o: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        current_y -= 20
        c.line(margin, current_y, width - margin, current_y)
        current_y -= 15 # Space after line

        # --- Content ---
        textobject = c.beginText(margin, current_y)
        textobject.setFont(FONT_NAME, 9) # Smaller font for content
        line_height = 11 # Adjust line height for smaller font

        # Function to add text lines and handle page breaks
        def add_lines_to_pdf(text_lines):
            nonlocal textobject, current_y # Allow modifying outer scope variables
            required_height = len(text_lines) * line_height + 5 # Estimate height needed + spacing
            if textobject.getY() - required_height < margin:
                c.drawText(textobject) # Draw existing text
                c.showPage() # New page
                # Optional: Redraw header on new page
                c.setFont(FONT_NAME, 10)
                c.drawString(margin, height - margin + 15, f"B√°o c√°o Access Points (ti·∫øp theo)")
                c.line(margin, height - margin + 5, width - margin, height - margin + 5)
                current_y = height - margin - 20
                textobject = c.beginText(margin, current_y) # Start new text object
                textobject.setFont(FONT_NAME, 9)

            # Add the actual lines
            for line in text_lines:
                 # Basic cleaning for PDF output
                 clean_line = line.replace("üì° **", "SSID: ").replace("üîç **", "BSSID: ").replace("üîí **", "B·∫£o m·∫≠t: ").replace("üì∂ **", "K√™nh/T√≠n hi·ªáu: ")
                 clean_line = clean_line.replace("`", "").replace("**", "") # Remove markdown
                 if "„Ä∞Ô∏è„Ä∞Ô∏è„Ä∞Ô∏è" in clean_line or "----" in clean_line:
                      # Draw a separator line within the text object if possible, or just add space
                      textobject.moveCursor(0, 3) # Add small space before
                      textobject.textLine("-" * 80) # Draw a simple line
                      textobject.moveCursor(0, 3) # Add small space after
                 else:
                     textobject.textLine(clean_line)
            textobject.moveCursor(0, 5) # Add a small gap between entries


        for ap_entry in ap_list_formatted:
            lines = ap_entry.strip().split('\n')
            add_lines_to_pdf(lines)


        c.drawText(textobject) # Draw any remaining text
        c.save() # Save file PDF

        # --- Send PDF ---
        try:
            with open(pdf_filename, "rb") as pdf_file:
                await update.message.reply_document(
                    document=InputFile(pdf_file, filename=pdf_filename),
                    caption=f"Danh s√°ch Access Points ({len(ap_list_formatted)} APs) ƒë∆∞·ª£c t·∫°o l√∫c {datetime.now().strftime('%H:%M:%S %d/%m/%Y')}"
                )
            logger.info(f"ƒê√£ g·ª≠i th√†nh c√¥ng file PDF: {pdf_filename}")
        except Exception as send_err:
             logger.error(f"L·ªói khi g·ª≠i file PDF {pdf_filename}: {send_err}")
             await update.message.reply_text(f"‚ùå ƒê√£ t·∫°o PDF nh∆∞ng l·ªói khi g·ª≠i: {send_err}")

    except Exception as e:
        logger.error(f"L·ªói nghi√™m tr·ªçng khi t·∫°o PDF: {e}", exc_info=True) # Log traceback
        await update.message.reply_text(f"‚ùå L·ªói kh√¥ng mong mu·ªën khi t·∫°o PDF: {e}")
        if 'c' in locals() and c: # Try to close canvas if it exists
             try: c.save()
             except: pass


    finally:
        # Clean up the PDF file
        if os.path.exists(pdf_filename):
            try:
                os.remove(pdf_filename)
                logger.info(f"ƒê√£ x√≥a file t·∫°m: {pdf_filename}")
            except OSError as e:
                logger.error(f"Kh√¥ng th·ªÉ x√≥a file t·∫°m {pdf_filename}: {e}")

async def alert_command(update: Update, context: CallbackContext):
    """L·∫•y v√† g·ª≠i danh s√°ch c·∫£nh b√°o."""
    await update.message.reply_text("üîî ƒêang ki·ªÉm tra 5 c·∫£nh b√°o Kismet g·∫ßn nh·∫•t...")
    result = await get_alerts(limit=5) # L·∫•y 5 c·∫£nh b√°o g·∫ßn nh·∫•t
    if result and isinstance(result, list) and result[0].startswith("‚ùå"):
        await update.message.reply_text(result[0])
    elif not result:
         await update.message.reply_text("‚ÑπÔ∏è Kh√¥ng c√≥ c·∫£nh b√°o n√†o.")
    else:
        result_text = "\n\n".join(result)
        if not result_text.strip() or "Kh√¥ng c√≥ c·∫£nh b√°o n√†o" in result_text :
            await update.message.reply_text("‚úÖ Kh√¥ng c√≥ c·∫£nh b√°o n√†o trong 5 c·∫£nh b√°o g·∫ßn nh·∫•t.")
        else:
            for part in split_message(result_text):
                await update.message.reply_text(part, parse_mode="Markdown")


async def client_command(update: Update, context: CallbackContext):
    """L·∫•y danh s√°ch client k·∫øt n·ªëi v√†o m·ªôt SSID."""
    if not context.args:
        await update.message.reply_text(
            "‚ö†Ô∏è Vui l√≤ng nh·∫≠p **SSID** c·ªßa AP!\n"
            "V√≠ d·ª•: `/client Tenda_123` ho·∫∑c `/client \"My Wifi Network\"` (d√πng ngo·∫∑c k√©p n·∫øu SSID c√≥ kho·∫£ng tr·∫Øng).",
            parse_mode="Markdown"
        )
        return

    # Join args to handle SSIDs with spaces (even without quotes, though quotes are better)
    ssid_filter = " ".join(context.args).strip()
    if not ssid_filter:
         await update.message.reply_text("‚ö†Ô∏è B·∫°n ch∆∞a nh·∫≠p SSID.", parse_mode="Markdown")
         return

    await update.message.reply_text(f"üë• ƒêang t√¨m client k·∫øt n·ªëi v√†o AP c√≥ SSID: **{ssid_filter}**...", parse_mode="Markdown")

    result = await get_clients_by_ap(ssid_filter) # result is a list of strings

    # Check for error message from the function
    if result and isinstance(result, list) and result[0].startswith("‚ùå"):
        await update.message.reply_text(result[0], parse_mode="Markdown")
    # Check for "not found" messages from the function
    elif result and isinstance(result, list) and ("Kh√¥ng t√¨m th·∫•y AP n√†o" in result[0] or "Kh√¥ng t√¨m th·∫•y client n√†o" in result[0] or "Kh√¥ng nh·∫≠n ƒë∆∞·ª£c d·ªØ li·ªáu" in result[0]):
         await update.message.reply_text(result[0], parse_mode="Markdown") # Send the specific "not found" message
    elif not result:
         # Generic fallback if function returns empty for some reason
         await update.message.reply_text(f"‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y th√¥ng tin client cho SSID: **{ssid_filter}**.", parse_mode="Markdown")
    else:
        # Join with single newline as the header is already included in the list
        result_text = "\n".join(result)
        for part in split_message(result_text):
            await update.message.reply_text(part, parse_mode="Markdown")


async def monitor_command(update: Update, context: CallbackContext):
    """Ki·ªÉm tra s·ª± thay ƒë·ªïi SSID v√† b√°o c√°o RAP."""
    await update.message.reply_text("üö® ƒêang ki·ªÉm tra thay ƒë·ªïi SSID (RAP Detection)...")
    rogue_aps = await monitor_ssid_changes() # Returns list of strings or list with error

    if not rogue_aps:
        await update.message.reply_text("‚úÖ Kh√¥ng ph√°t hi·ªán BSSID n√†o thay ƒë·ªïi SSID b·∫•t th∆∞·ªùng.")
    # Check if the list contains an error message
    elif isinstance(rogue_aps, list) and rogue_aps[0].startswith("‚ùå"):
         await update.message.reply_text(f"{rogue_aps[0]}") # Display the error
    else:
        response = "‚ö†Ô∏è **C·∫£nh b√°o thay ƒë·ªïi SSID:**\n\n" + "\n\n".join(rogue_aps)
        for part in split_message(response):
            await update.message.reply_text(part, parse_mode="Markdown")

async def summary_command(update: Update, context: CallbackContext):
    """L·∫•y v√† hi·ªÉn th·ªã b√°o c√°o t√≥m t·∫Øt Kismet."""
    await update.message.reply_text("üìä ƒêang t·∫°o b√°o c√°o t√≥m t·∫Øt Kismet...")

    summary_data = await get_summary_data()

    # --- Format Error Message (if any) ---
    error_message = ""
    if summary_data["errors"]:
        error_message = "‚ö†Ô∏è *ƒê√£ x·∫£y ra l·ªói khi l·∫•y m·ªôt ph·∫ßn d·ªØ li·ªáu t√≥m t·∫Øt:*\n- " + "\n- ".join(summary_data["errors"]) + "\n\n_(K·∫øt qu·∫£ b√™n d∆∞·ªõi c√≥ th·ªÉ kh√¥ng ƒë·∫ßy ƒë·ªß)_"
        # Log the errors clearly
        logger.error(f"L·ªói trong summary_command: {summary_data['errors']}")


    # --- Format Result Message ---
    summary_text = "üìä **B√°o c√°o T√≥m t·∫Øt Kismet** üìä\n"
    summary_text += "------------------------------------\n"
    summary_text += f"üì° **T·ªïng s·ªë Access Points:** `{summary_data['ap_count']}`\n"
    summary_text += f"üì± **T·ªïng s·ªë Clients Wi-Fi:** `{summary_data['client_count']}`\n"
    summary_text += f"üîî **C·∫£nh b√°o m·ªõi (24h):** `{summary_data['new_alert_count']}`\n"
    summary_text += "------------------------------------\n\n"

    if summary_data["strongest_ap"] and summary_data['max_ap_signal'] > -1000: # Check if data exists
        ap = summary_data['strongest_ap']
        signal = summary_data['max_ap_signal']
        summary_text += (f"üëë **AP T√≠n hi·ªáu M·∫°nh nh·∫•t:**\n"
                         f"   SSID: `{ap['ssid']}`\n"
                         f"   BSSID: `{ap['bssid'].upper()}`\n"
                         f"   T√≠n hi·ªáu: `{signal} dBm`\n\n")
    else:
        summary_text += "üëë **AP T√≠n hi·ªáu M·∫°nh nh·∫•t:** `(Kh√¥ng c√≥ d·ªØ li·ªáu ho·∫∑c kh√¥ng t√¨m th·∫•y AP)`\n\n"

    if summary_data["strongest_client"] and summary_data['max_client_signal'] > -1000: # Check if data exists
        client = summary_data['strongest_client']
        signal = summary_data['max_client_signal']
        summary_text += (f"üí™ **Client T√≠n hi·ªáu M·∫°nh nh·∫•t:**\n"
                         f"   MAC: `{client['mac'].upper()}`\n"
                         f"   T√≠n hi·ªáu: `{signal} dBm`\n")
    else:
        summary_text += "üí™ **Client T√≠n hi·ªáu M·∫°nh nh·∫•t:** `(Kh√¥ng c√≥ d·ªØ li·ªáu ho·∫∑c kh√¥ng t√¨m th·∫•y client)`\n"

    # --- Send Message(s) ---
    # Send error message first if it exists
    if error_message:
        await update.message.reply_text(error_message, parse_mode="Markdown", reply_markup=None)
        # Maybe add a small delay if needed
        # await asyncio.sleep(0.5)

    # Send the main summary
    await update.message.reply_text(summary_text, parse_mode="Markdown", reply_markup=None)


# --- NEW: Type Command Handler ---
async def type_command(update: Update, context: CallbackContext):
    """Gi·∫£i th√≠ch √Ω nghƒ©a c·ªßa m·ªôt m√£ c·∫£nh b√°o Kismet."""
    if not context.args:
        await update.message.reply_text(
            "‚ö†Ô∏è Vui l√≤ng nh·∫≠p m√£ c·∫£nh b√°o Kismet c·∫ßn gi·∫£i th√≠ch.\n"
            "V√≠ d·ª•: `/type DEAUTHFLOOD`",
            parse_mode="Markdown"
        )
        return

    alert_code = context.args[0].upper().strip() # Get first arg, convert to uppercase, remove whitespace

    # Lookup description in the dictionary (case-insensitive due to .upper())
    description = ALERT_DESCRIPTIONS.get(alert_code)

    if description:
        response_text = f"‚ÑπÔ∏è **{alert_code}:**\n\n{description}"
        await update.message.reply_text(response_text, parse_mode="Markdown")
    else:
        await update.message.reply_text(
            f"‚ùå Kh√¥ng t√¨m th·∫•y gi·∫£i th√≠ch cho m√£ c·∫£nh b√°o: `{alert_code}`.\n"
            "Vui l√≤ng ki·ªÉm tra l·∫°i m√£ ho·∫∑c ƒë·∫£m b·∫£o ƒë√≥ l√† m√£ c·∫£nh b√°o Wi-Fi h·ª£p l·ªá t·ª´ Kismet.",
             parse_mode="Markdown"
             )

# --- Error Handler ---
async def error_handler(update: object, context: CallbackContext):
    """Log l·ªói v√† th√¥ng b√°o cho ng∆∞·ªùi d√πng."""
    # Log the error before anything else
    logger.error(f"Exception while handling an update: {context.error}", exc_info=context.error)

    # Attempt to notify the user, checking if 'update' is valid and has a message
    if isinstance(update, Update) and update.effective_message:
        try:
            # Escape any special characters in the error message for Markdown
            # error_text = html.escape(str(context.error)) # Or use html escape if preferred
            # You might want a simpler user message instead of the raw error
            user_message = "‚ùå R·∫•t ti·∫øc, ƒë√£ c√≥ l·ªói x·∫£y ra trong qu√° tr√¨nh x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n. Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá qu·∫£n tr·ªã vi√™n n·∫øu l·ªói ti·∫øp di·ªÖn."
            # Consider adding a reference ID or timestamp for admins?
            # error_id = int(time.time())
            # logger.error(f"Error ID {error_id}: {context.error}", exc_info=context.error)
            # user_message += f" (Ref: {error_id})"

            await update.effective_message.reply_text(user_message)
        except Exception as e:
            # Log the failure to notify the user too
            logger.error(f"Could not send error message to user after an exception: {e}")

# --- Setup and Run ---
def setup_handlers(application):
    """ƒêƒÉng k√Ω t·∫•t c·∫£ c√°c command handler."""
    handlers = [
        CommandHandler("start", start),
        CommandHandler("help", help_command),
        CommandHandler("ap", ap_command),
        CommandHandler("summary", summary_command),
        CommandHandler("alert", alert_command),
        CommandHandler("client", client_command),
        CommandHandler("monitor", monitor_command),
        CommandHandler("appdf", appdf_command),
        CommandHandler("type", type_command), # Add the new handler
         # MessageHandler to catch non-command text - perhaps suggest /help
         MessageHandler(filters.TEXT & ~filters.COMMAND, help_command) # Redirect non-commands to help
    ]
    for handler in handlers:
        application.add_handler(handler)

    # Register the error handler
    application.add_error_handler(error_handler)
    logger.info("ƒê√£ ƒëƒÉng k√Ω c√°c command v√† error handlers.")

def main():
    """Kh·ªüi ch·∫°y bot Telegram."""
    logger.info("--- Bot Starting Up ---")
    if not TOKEN or "YOUR_TELEGRAM_BOT_TOKEN" in TOKEN:
         logger.critical("FATAL: Telegram Bot Token is missing or invalid!")
         print("FATAL: Telegram Bot Token is missing or invalid! Please set the TOKEN variable.", flush=True)
         return # Stop execution

    # Basic Kismet connection check (optional but helpful)
    logger.info(f"Ki·ªÉm tra k·∫øt n·ªëi Kismet t·∫°i {KISMET_URL}...")
    try:
        # Use a simple endpoint like /system/status.json
        status_url = f"{KISMET_URL}/system/status.json"
        response = requests.get(status_url, auth=HTTPBasicAuth(KISMET_USERNAME, KISMET_PASSWORD), timeout=5)
        response.raise_for_status()
        logger.info(f"K·∫øt n·ªëi Kismet th√†nh c√¥ng (Status code: {response.status_code}).")
    except requests.exceptions.ConnectionError:
        logger.error(f"L·ªói Startup: Kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi Kismet t·∫°i {KISMET_URL}.")
        print(f"L·ªói Startup: Kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi Kismet t·∫°i {KISMET_URL}. Bot s·∫Ω v·∫´n kh·ªüi ch·∫°y nh∆∞ng c√°c l·ªánh Kismet s·∫Ω th·∫•t b·∫°i.", flush=True)
    except requests.exceptions.HTTPError as http_err:
         if http_err.response.status_code == 401:
              logger.error("L·ªói Startup: Sai th√¥ng tin x√°c th·ª±c Kismet (Username/Password).")
              print("L·ªói Startup: Sai th√¥ng tin x√°c th·ª±c Kismet. Bot s·∫Ω v·∫´n kh·ªüi ch·∫°y nh∆∞ng c√°c l·ªánh Kismet s·∫Ω th·∫•t b·∫°i.", flush=True)
         else:
              logger.error(f"L·ªói Startup: L·ªói HTTP khi k·∫øt n·ªëi Kismet: {http_err}")
              print(f"L·ªói Startup: L·ªói HTTP khi k·∫øt n·ªëi Kismet: {http_err}. Bot s·∫Ω v·∫´n kh·ªüi ch·∫°y nh∆∞ng c√°c l·ªánh Kismet s·∫Ω th·∫•t b·∫°i.", flush=True)
    except requests.exceptions.Timeout:
        logger.error("L·ªói Startup: Timeout khi k·∫øt n·ªëi Kismet.")
        print("L·ªói Startup: Timeout khi k·∫øt n·ªëi Kismet. Bot s·∫Ω v·∫´n kh·ªüi ch·∫°y nh∆∞ng c√°c l·ªánh Kismet s·∫Ω th·∫•t b·∫°i.", flush=True)
    except Exception as conn_err:
        logger.error(f"L·ªói Startup: L·ªói kh√¥ng x√°c ƒë·ªãnh khi ki·ªÉm tra k·∫øt n·ªëi Kismet: {conn_err}")
        print(f"L·ªói Startup: L·ªói kh√¥ng x√°c ƒë·ªãnh khi ki·ªÉm tra k·∫øt n·ªëi Kismet: {conn_err}. Bot s·∫Ω v·∫´n kh·ªüi ch·∫°y nh∆∞ng c√°c l·ªánh Kismet s·∫Ω th·∫•t b·∫°i.", flush=True)


    try:
        application = Application.builder().token(TOKEN).build()
        setup_handlers(application)
        logger.info("Bot ƒëang b·∫Øt ƒë·∫ßu ch·∫°y v√† l·∫Øng nghe updates...")
        print("Bot is running...", flush=True)
        application.run_polling()
    except Exception as e:
        logger.critical(f"L·ªói nghi√™m tr·ªçng khi kh·ªüi t·∫°o ho·∫∑c ch·∫°y application.run_polling(): {e}", exc_info=True)
        print(f"CRITICAL ERROR: Bot failed to start or run. Check bot.log for details. Error: {e}", flush=True)

if __name__ == "__main__":
    main()
