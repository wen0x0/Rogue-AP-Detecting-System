import logging
import requests
from requests.auth import HTTPBasicAuth
from telegram import Update, InputFile, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from reportlab.lib.units import inch
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.pdfbase import pdfmetrics
import os
import time
from datetime import datetime, timedelta

TOKEN = "8074321892:AAF6glPFFhVkWdS_FWVBYaMN4MkE8jsEjmY"

KISMET_URL = "http://localhost:2501"
KISMET_USERNAME = "kali" 
KISMET_PASSWORD = "kali" 


FONT_PATH = "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"
FONT_NAME = "DejaVu"

logging.basicConfig(
    filename="bot.log",
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

ssid_history = {}



def register_font():
    """ÄÄƒng kÃ½ font chá»¯ náº¿u tá»“n táº¡i."""
    if os.path.exists(FONT_PATH):
        try:
            pdfmetrics.registerFont(TTFont(FONT_NAME, FONT_PATH))
            logger.info(f"ÄÃ£ Ä‘Äƒng kÃ½ font thÃ nh cÃ´ng: {FONT_PATH}")
            return True
        except Exception as e:
            logger.error(f"Lá»—i Ä‘Äƒng kÃ½ font {FONT_PATH}: {e}")
            return False
    else:
        logger.warning(f"KhÃ´ng tÃ¬m tháº¥y file font táº¡i: {FONT_PATH}. Chá»©c nÄƒng PDF cÃ³ thá»ƒ bá»‹ áº£nh hÆ°á»Ÿng.")
        return False


FONT_REGISTERED = register_font()

# ğŸ“¡ HÃ m láº¥y dá»¯ liá»‡u tá»« Kismet API
def fetch_kismet_data(endpoint):
    try:
        url = f"{KISMET_URL}{endpoint}"
        response = requests.get(url, auth=HTTPBasicAuth(KISMET_USERNAME, KISMET_PASSWORD), timeout=15) 
        response.raise_for_status() #

        content_type = response.headers.get("Content-Type", "")
        if "application/json" not in content_type:
            logger.error(f"Kismet endpoint {endpoint} khÃ´ng tráº£ vá» JSON. Content-Type: {content_type}")
            return None, f"âŒ Dá»¯ liá»‡u tráº£ vá» tá»« Kismet khÃ´ng há»£p lá»‡ (khÃ´ng pháº£i JSON) cho endpoint: {endpoint}"

        return response.json(), None

    except requests.exceptions.ConnectionError as e:
        logger.error(f"Lá»—i káº¿t ná»‘i Kismet: {e}")
        return None, f"âŒ Lá»—i káº¿t ná»‘i Kismet: KhÃ´ng thá»ƒ káº¿t ná»‘i tá»›i {KISMET_URL}. Vui lÃ²ng kiá»ƒm tra Kismet cÃ³ Ä‘ang cháº¡y vÃ  URL/port Ä‘Ãºng khÃ´ng."
    except requests.exceptions.Timeout:
        logger.error(f"Lá»—i Kismet Timeout cho endpoint: {endpoint}")
        return None, f"âŒ Lá»—i Kismet Timeout: YÃªu cáº§u tá»›i {endpoint} máº¥t quÃ¡ nhiá»u thá»i gian."
    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 401:
            logger.error("Lá»—i xÃ¡c thá»±c Kismet (401).")
            return None, "âŒ Lá»—i xÃ¡c thá»±c Kismet (401): Vui lÃ²ng kiá»ƒm tra Username/Password."
        logger.error(f"Lá»—i HTTP tá»« Kismet ({e.response.status_code}): {e}")
        return None, f"âŒ Lá»—i HTTP tá»« Kismet ({e.response.status_code}) cho endpoint: {endpoint}."
    except requests.exceptions.RequestException as e:
        logger.error(f"Lá»—i yÃªu cáº§u Kismet khÃ´ng xÃ¡c Ä‘á»‹nh: {e}")
        return None, f"âŒ Lá»—i yÃªu cáº§u Kismet khÃ´ng xÃ¡c Ä‘á»‹nh: {e}"
    except ValueError as e: # Lá»—i khi parse JSON
        logger.error(f"Lá»—i parse JSON tá»« Kismet endpoint {endpoint}: {e}")
        return None, f"âŒ Dá»¯ liá»‡u tráº£ vá» tá»« Kismet khÃ´ng há»£p lá»‡ (lá»—i parse JSON) cho endpoint: {endpoint}"

# Chia nhá» tin nháº¯n náº¿u vÆ°á»£t quÃ¡ giá»›i háº¡n Telegram (4096 kÃ½ tá»±)
def split_message(text, chunk_size=4000):
    if not isinstance(text, str): 
       text = str(text)
    for i in range(0, len(text), chunk_size):
        yield text[i:i + chunk_size]


async def get_all_ap():
    """Láº¥y danh sÃ¡ch APs vÃ  Ä‘á»‹nh dáº¡ng chÃºng thÃ nh list cÃ¡c string."""
    data, error = fetch_kismet_data("/devices/views/phydot11_accesspoints/devices.json")
    if error:
        return [error]

    if not data or not isinstance(data, list):
         logger.warning("Dá»¯ liá»‡u APs tráº£ vá» khÃ´ng pháº£i list hoáº·c rá»—ng.")
         return ["â„¹ï¸ KhÃ´ng nháº­n Ä‘Æ°á»£c dá»¯ liá»‡u AP há»£p lá»‡ tá»« Kismet hoáº·c khÃ´ng cÃ³ AP nÃ o."]

    ap_list = []
    for ap in data:
        if ap.get("kismet.device.base.type") == "Wi-Fi AP":
            ssid = ap.get("kismet.device.base.commonname", "áº¨n/KhÃ´ng tÃªn")
            bssid = ap.get("kismet.device.base.macaddr", "Unknown BSSID")
            encryption=ap.get("kismet.device.base.crypt","Unknown_Encryption")
           
            signal_info = ap.get("kismet.common.signal", {})
            signal_dbm = signal_info.get("last_signal_dbm", "N/A")
            channel = ap.get("kismet.phy.dot11.channel", "N/A") # Láº¥y kÃªnh

            ap_list.append(
                f"ğŸ“¡ **SSID:** `{ssid}`\n"
                f"ğŸ” **BSSID:** `{bssid.upper()}`\n"
                f"ğŸ”’ **Báº£o máº­t:** `{encryption}`\n"
                f"ğŸ“¶ **KÃªnh:** `{channel}` | **TÃ­n hiá»‡u:** `{signal_dbm} dBm`\n" 
                f"ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸"
            )

    return ap_list if ap_list else ["âœ… KhÃ´ng tÃ¬m tháº¥y AP nÃ o!"]

async def get_ap_monitor_data():
    """Láº¥y dá»¯ liá»‡u SSID vÃ  BSSID cáº§n thiáº¿t cho viá»‡c giÃ¡m sÃ¡t."""
    data, error = fetch_kismet_data("/devices/views/phydot11_accesspoints/devices.json")
    if error:
        return None, error

    if not data or not isinstance(data, list):
         logger.warning("Dá»¯ liá»‡u APs monitor tráº£ vá» khÃ´ng pháº£i list hoáº·c rá»—ng.")
         return [], None 

    ap_pairs = []
    for ap in data:
        if ap.get("kismet.device.base.type") == "Wi-Fi AP":
            ssid = ap.get("kismet.device.base.commonname", "Unknown_SSID")
            bssid = ap.get("kismet.device.base.macaddr")
            if bssid: 
               ap_pairs.append({"ssid": ssid, "bssid": bssid.lower()}) 

    return ap_pairs, None

async def monitor_ssid_changes():
    """GiÃ¡m sÃ¡t sá»± thay Ä‘á»•i SSID cá»§a cÃ¡c AP Ä‘Ã£ biáº¿t BSSID."""
    global ssid_history
    ap_pairs, error = await get_ap_monitor_data()

    if error:
        return [error] # Tráº£ vá» lá»—i

    if ap_pairs is None: 
        return ["âŒ KhÃ´ng thá»ƒ láº¥y dá»¯ liá»‡u AP Ä‘á»ƒ giÃ¡m sÃ¡t."]

    rogue_aps = []

    current_bssid_map = {ap['bssid']: ap['ssid'] for ap in ap_pairs}

    for bssid, current_ssid in current_bssid_map.items():
        if bssid not in ssid_history:
            # BSSID má»›i, ghi nháº­n láº§n Ä‘áº§u
            ssid_history[bssid] = {current_ssid}
        elif current_ssid not in ssid_history[bssid]:
            # BSSID Ä‘Ã£ biáº¿t nhÆ°ng cÃ³ SSID má»›i
            old_ssids = ssid_history[bssid]
            ssid_history[bssid].add(current_ssid) # ThÃªm SSID má»›i vÃ o lá»‹ch sá»­
            rogue_aps.append(f"ğŸš¨ **RAP Detected (SSID Change):**\n"
                             f"   BSSID: `{bssid.upper()}`\n"
                             f"   SSID Má»›i: `{current_ssid}`\n"
                             f"   SSIDs TrÆ°á»›c Ä‘Ã³: `{', '.join(old_ssids)}`")
            logger.warning(f"RAP PhÃ¡t hiá»‡n (SSID Change): BSSID: {bssid}, SSID má»›i: {current_ssid}, SSIDs cÅ©: {old_ssids}")
    return rogue_aps if rogue_aps else [] 

async def get_alerts(limit=5):
    """Láº¥y danh sÃ¡ch cáº£nh bÃ¡o tá»« Kismet (giá»›i háº¡n sá»‘ lÆ°á»£ng)."""
    data, error = fetch_kismet_data("/alerts/all_alerts.json")
    if error:
        return [error]

    if not data or not isinstance(data, list):
        return ["âœ… KhÃ´ng cÃ³ cáº£nh bÃ¡o nÃ o tá»« Kismet hoáº·c dá»¯ liá»‡u khÃ´ng há»£p lá»‡!"]
    try:
        sorted_alerts = sorted(data, key=lambda x: x.get('kismet.alert.timestamp', 0) or x.get('kismet.alert.sec', 0), reverse=True)
    except Exception as e:
        logger.warning(f"KhÃ´ng thá»ƒ sáº¯p xáº¿p cáº£nh bÃ¡o theo timestamp: {e}. Sá»­ dá»¥ng thá»© tá»± gá»‘c.")
        sorted_alerts = data

    latest_alerts = sorted_alerts[:limit] 
    alert_list = []
    for alert in latest_alerts:
        header = alert.get("kismet.alert.header", "N/A")
        text = alert.get("kismet.alert.text", "KhÃ´ng cÃ³ mÃ´ táº£")

        # Láº¥y timestamp vÃ  Ä‘á»‹nh dáº¡ng
        timestamp_sec = alert.get('kismet.alert.timestamp') or alert.get('kismet.alert.sec', 0)
        if timestamp_sec:
            try:
                dt_object = datetime.fromtimestamp(timestamp_sec)
                timestamp_str = dt_object.strftime("%Y-%m-%d %H:%M:%S")
            except Exception:
                timestamp_str = str(timestamp_sec) 
        else:
            timestamp_str = "N/A"

        alert_list.append(f"ğŸ”” **{header}**\n"
                          f"   ğŸ“Œ {text}\n"
                          f"   ğŸ•’ {timestamp_str}\n"
                          f"{'-'*30}")

    return alert_list if alert_list else ["âœ… KhÃ´ng cÃ³ cáº£nh bÃ¡o nÃ o trong giá»›i háº¡n yÃªu cáº§u."]


async def get_clients_by_ap(ssid_filter):
    logger.info(f"Báº¯t Ä‘áº§u tÃ¬m client cho SSID: {ssid_filter}")
    target_bssid = None
    aps_data, aps_error = fetch_kismet_data("/devices/views/phydot11_accesspoints/devices.json")
    if aps_error:
        return [f"âŒ Lá»—i khi tÃ¬m BSSID cho SSID '{ssid_filter}': {aps_error}"]
    if not aps_data or not isinstance(aps_data, list):
        return [f"â„¹ï¸ KhÃ´ng tÃ¬m tháº¥y AP nÃ o cÃ³ SSID khá»›p '{ssid_filter}'."]

    found_aps = []
    for ap in aps_data:
        if ap.get("kismet.device.base.type") == "Wi-Fi AP":
             ap_ssid = ap.get("kismet.device.base.commonname", "")
             if ap_ssid.strip().lower() == ssid_filter.strip().lower():
                  bssid = ap.get("kismet.device.base.macaddr")
                  if bssid:
                      found_aps.append(bssid.lower()) 

    if not found_aps:
        return [f"âœ… KhÃ´ng tÃ¬m tháº¥y AP nÃ o Ä‘ang hoáº¡t Ä‘á»™ng vá»›i SSID: **{ssid_filter}**"]
    if len(found_aps) > 1:
        logger.warning(f"TÃ¬m tháº¥y nhiá»u AP ({len(found_aps)}) vá»›i SSID '{ssid_filter}'. Sá»­ dá»¥ng BSSID Ä‘áº§u tiÃªn: {found_aps[0]}")

    target_bssid = found_aps[0] # Láº¥y BSSID Ä‘áº§u tiÃªn tÃ¬m Ä‘Æ°á»£c
    logger.info(f"TÃ¬m tháº¥y BSSID {target_bssid.upper()} cho SSID '{ssid_filter}'")

    clients_list = []
    all_dev_data, dev_error = fetch_kismet_data("/devices/by-mac/*/device.json")
    if dev_error:
         # Thá»­ endpoint khÃ¡c náº¿u endpoint trÃªn khÃ´ng hoáº¡t Ä‘á»™ng
         logger.warning("KhÃ´ng thá»ƒ dÃ¹ng /devices/by-mac/*/device.json, thá»­ /devices/views/phy-IEEE802.11/devices.json")
         all_dev_data, dev_error = fetch_kismet_data("/devices/views/phy-IEEE802.11/devices.json")
         if dev_error:
              return [f"âŒ Lá»—i khi láº¥y danh sÃ¡ch thiáº¿t bá»‹: {dev_error}"]

    if not all_dev_data or not isinstance(all_dev_data, list): 
        return ["â„¹ï¸ KhÃ´ng nháº­n Ä‘Æ°á»£c dá»¯ liá»‡u thiáº¿t bá»‹ há»£p lá»‡ tá»« Kismet."]

    for device in all_dev_data:
        if device.get("kismet.device.base.type") == "Wi-Fi Client":
            last_bssid = (device.get("dot11.device", {}).get("dot11.device.last_bssid") or
                          device.get("kismet.wireless.client. BSSID")) # ThÃªm trÆ°á»ng dá»± phÃ²ng náº¿u cáº§n

            if last_bssid and last_bssid.lower() == target_bssid:
                mac_address = device.get("kismet.device.base.macaddr", "Unknown MAC")
                signal_info = device.get("kismet.common.signal", {})
                signal_dbm = signal_info.get("last_signal_dbm", "N/A")
                clients_list.append(f"ğŸ“± **MAC:** `{mac_address.upper()}` | **TÃ­n hiá»‡u:** `{signal_dbm} dBm`")

    logger.info(f"TÃ¬m tháº¥y {len(clients_list)} client cho BSSID {target_bssid.upper()}")
    if not clients_list:
         return [f"âœ… KhÃ´ng tÃ¬m tháº¥y client nÃ o Ä‘ang káº¿t ná»‘i vÃ o AP **{ssid_filter}** (BSSID: `{target_bssid.upper()}`)"]
    else:
        return [f"ğŸ‘¥ Client Ä‘ang káº¿t ná»‘i vÃ o **{ssid_filter}** (BSSID: `{target_bssid.upper()}`):"] + clients_list


async def get_summary_data():
    """Láº¥y dá»¯ liá»‡u tÃ³m táº¯t tá»« Kismet (APs, Clients, Alerts)."""
    summary = {
        "ap_count": 0,
        "client_count": 0,
        "new_alert_count": 0,
        "strongest_ap": None,
        "max_ap_signal": -1000,
        "strongest_client": None,
        "max_client_signal": -1000,
        "errors": []
    }
    start_time = time.time()
    logger.info("Báº¯t Ä‘áº§u láº¥y dá»¯ liá»‡u tÃ³m táº¯t...")

    ap_data, ap_error = fetch_kismet_data("/devices/views/phydot11_accesspoints/devices.json")
    if ap_error:
        summary["errors"].append(f"Lá»—i láº¥y AP: {ap_error}")
    elif ap_data and isinstance(ap_data, list):
        for ap in ap_data:
            if ap.get("kismet.device.base.type") == "Wi-Fi AP":
                summary["ap_count"] += 1
                try:
                    signal_dbm = ap.get("kismet.common.signal", {}).get("last_signal_dbm")
                    # Chá»‰ cáº­p nháº­t strongest_ap náº¿u tÃ­n hiá»‡u há»£p lá»‡ vÃ  máº¡nh hÆ¡n
                    if signal_dbm is not None and isinstance(signal_dbm, (int, float)) and signal_dbm > summary["max_ap_signal"]:
                        summary["max_ap_signal"] = signal_dbm
                        summary["strongest_ap"] = {
                            "ssid": ap.get("kismet.device.base.commonname", "N/A"),
                            "bssid": ap.get("kismet.device.base.macaddr", "N/A")
                        }
                except Exception as e:
                    logger.warning(f"Summary: KhÃ´ng thá»ƒ xá»­ lÃ½ tÃ­n hiá»‡u AP {ap.get('kismet.device.base.macaddr')}: {e}")
    else:
         logger.warning("Summary: Dá»¯ liá»‡u AP khÃ´ng há»£p lá»‡ hoáº·c rá»—ng.")


    client_data, client_error = fetch_kismet_data("/devices/views/phy-IEEE802.11/devices.json") 
    if client_error:
        summary["errors"].append(f"Lá»—i láº¥y Client: {client_error}")
    elif client_data and isinstance(client_data, list):
         for device in client_data:
             if device.get("kismet.device.base.type") == "Wi-Fi Client":
                summary["client_count"] += 1
                try:
                    signal_dbm = device.get("kismet.common.signal", {}).get("last_signal_dbm")
                    if signal_dbm is not None and isinstance(signal_dbm, (int, float)) and signal_dbm > summary["max_client_signal"]:
                        summary["max_client_signal"] = signal_dbm
                        summary["strongest_client"] = {
                            "mac": device.get("kismet.device.base.macaddr", "N/A")
                        }
                except Exception as e:
                     logger.warning(f"Summary: KhÃ´ng thá»ƒ xá»­ lÃ½ tÃ­n hiá»‡u Client {device.get('kismet.device.base.macaddr')}: {e}")
    else:
        logger.warning("Summary: Dá»¯ liá»‡u client khÃ´ng há»£p lá»‡ hoáº·c rá»—ng.")


    alert_data, alert_error = fetch_kismet_data("/alerts/all_alerts.json")
    if alert_error:
        summary["errors"].append(f"Lá»—i láº¥y Cáº£nh bÃ¡o: {alert_error}")
    elif alert_data and isinstance(alert_data, list):
        cutoff_timestamp = (datetime.now() - timedelta(hours=24)).timestamp()

        for alert in alert_data:
            try:
                 alert_timestamp = alert.get('kismet.alert.timestamp') or alert.get('kismet.alert.sec')
                 if alert_timestamp and isinstance(alert_timestamp, (int, float)):
                     if alert_timestamp >= cutoff_timestamp:
                         summary["new_alert_count"] += 1
            except Exception as e:
                 logger.warning(f"Summary: KhÃ´ng thá»ƒ xá»­ lÃ½ timestamp cáº£nh bÃ¡o {alert.get('alert_key', 'N/A')}: {e}")
    else:
        logger.warning("Summary: Dá»¯ liá»‡u cáº£nh bÃ¡o khÃ´ng há»£p lá»‡ hoáº·c rá»—ng.")

    end_time = time.time()
    logger.info(f"HoÃ n thÃ nh láº¥y dá»¯ liá»‡u tÃ³m táº¯t trong {end_time - start_time:.2f} giÃ¢y.")
    return summary


# --- Telegram Command Handlers ---

async def start(update: Update, context: CallbackContext):
    """Xá»­ lÃ½ lá»‡nh /start."""
    user_name = update.effective_user.first_name
    keyboard = [
        [KeyboardButton("/ap"), KeyboardButton("/summary")],
        [KeyboardButton("/alert"), KeyboardButton("/monitor")],
        [KeyboardButton("/appdf"), KeyboardButton("/help")],
        [KeyboardButton("TÃ¬m Client (nháº­p /client SSID)")]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
    await update.message.reply_text(
        f"ğŸ‘‹ Xin chÃ o {user_name}!\n"
        "TÃ´i lÃ  Bot Kismet. Sá»­ dá»¥ng cÃ¡c nÃºt bÃªn dÆ°á»›i hoáº·c gÃµ lá»‡nh.\n"
        "GÃµ /help Ä‘á»ƒ xem mÃ´ táº£ chi tiáº¿t cÃ¡c lá»‡nh.",
        reply_markup=reply_markup
    )

async def help_command(update: Update, context: CallbackContext):
    """Hiá»ƒn thá»‹ danh sÃ¡ch cÃ¡c lá»‡nh."""
    help_text = (
        "ğŸ“Œ **Danh sÃ¡ch lá»‡nh cÃ³ sáºµn:**\n\n"
        "`/start` - Hiá»ƒn thá»‹ tin nháº¯n chÃ o má»«ng vÃ  bÃ n phÃ­m lá»‡nh.\n\n"
        "`/help` - Hiá»ƒn thá»‹ danh sÃ¡ch lá»‡nh nÃ y.\n\n"
        "`/ap` - ğŸ“¡ Láº¥y danh sÃ¡ch Access Point (APs) phÃ¡t hiá»‡n Ä‘Æ°á»£c tá»« Kismet (bao gá»“m SSID, BSSID, Báº£o máº­t, KÃªnh, TÃ­n hiá»‡u).\n\n"
        "`/summary` - ğŸ“Š Xem bÃ¡o cÃ¡o tÃ³m táº¯t nhanh vá» Kismet (sá»‘ lÆ°á»£ng APs, Clients, cáº£nh bÃ¡o má»›i, thiáº¿t bá»‹ máº¡nh nháº¥t).\n\n"
        "`/alert` - ğŸ”” Xem 5 cáº£nh bÃ¡o Kismet gáº§n nháº¥t.\n\n"
        "`/client <SSID>` - ğŸ‘¥ Liá»‡t kÃª cÃ¡c client Ä‘ang káº¿t ná»‘i vÃ o má»™t AP cÃ³ SSID cá»¥ thá»ƒ (vÃ­ dá»¥: `/client MyWifi`).\n\n"
        "`/monitor` - ğŸš¨ Kiá»ƒm tra vÃ  bÃ¡o cÃ¡o náº¿u cÃ³ AP nÃ o Ä‘Ã£ biáº¿t (theo BSSID) thay Ä‘á»•i SSID.\n\n"
        "`/appdf` - ğŸ“„ Xuáº¥t danh sÃ¡ch Access Point hiá»‡n táº¡i thÃ nh file PDF (yÃªu cáº§u font chá»¯ Ä‘Æ°á»£c cÃ i Ä‘áº·t Ä‘Ãºng).\n"
        "\n_LÆ°u Ã½: Má»™t sá»‘ lá»‡nh cÃ³ thá»ƒ máº¥t vÃ i giÃ¢y Ä‘á»ƒ xá»­ lÃ½._"
    )
    await update.message.reply_text(help_text, parse_mode="Markdown", reply_markup=None)


async def ap_command(update: Update, context: CallbackContext):
    """Láº¥y vÃ  gá»­i danh sÃ¡ch APs."""
    await update.message.reply_text("ğŸ“¡ Äang láº¥y danh sÃ¡ch Access Points tá»« Kismet...")
    result = await get_all_ap() 
    if result and isinstance(result, list) and result[0].startswith("âŒ"):
         await update.message.reply_text(result[0])
    elif not result:
         await update.message.reply_text("â„¹ï¸ KhÃ´ng tÃ¬m tháº¥y AP nÃ o hoáº·c khÃ´ng cÃ³ dá»¯ liá»‡u.")
    else:
        result_text = "\n\n".join(result)
        if not result_text.strip(): 
            await update.message.reply_text("âœ… KhÃ´ng tÃ¬m tháº¥y AP nÃ o!")
        else:
            for part in split_message(result_text):
                await update.message.reply_text(part, parse_mode="Markdown")

async def appdf_command(update: Update, context: CallbackContext):
    """Xuáº¥t danh sÃ¡ch APs thÃ nh file PDF."""
    if not FONT_REGISTERED:
        await update.message.reply_text("âŒ Lá»—i: KhÃ´ng thá»ƒ táº¡o PDF do font chá»¯ chÆ°a Ä‘Æ°á»£c Ä‘Äƒng kÃ½ hoáº·c khÃ´ng tÃ¬m tháº¥y. Vui lÃ²ng kiá»ƒm tra cáº¥u hÃ¬nh `FONT_PATH` trong code vÃ  cÃ i Ä‘áº·t font chá»¯.")
        return

    await update.message.reply_text("ğŸ“„ Äang táº¡o file PDF danh sÃ¡ch Access Points...")

    ap_list_formatted = await get_all_ap() 

    if not ap_list_formatted or (isinstance(ap_list_formatted, list) and ap_list_formatted[0].startswith("âŒ")):
        error_msg = ap_list_formatted[0] if ap_list_formatted else "âš ï¸ KhÃ´ng cÃ³ dá»¯ liá»‡u AP Ä‘á»ƒ xuáº¥t PDF."
        await update.message.reply_text(error_msg)
        return

    pdf_filename = f"kismet_aps_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"

    try:
        c = canvas.Canvas(pdf_filename, pagesize=letter)
        width, height = letter
        margin = 0.75 * inch
        text_width = width - 2 * margin
        current_y = height - margin

        # --- Header ---
        c.setFont(FONT_NAME, 18)
        c.drawCentredString(width / 2, current_y, "BÃ¡o cÃ¡o Access Points - Kismet")
        current_y -= 30
        c.setFont(FONT_NAME, 10)
        c.drawString(margin, current_y, f"NgÃ y táº¡o: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        current_y -= 25
        c.line(margin, current_y, width - margin, current_y) 
        current_y -= 20

        # --- Content ---
        textobject = c.beginText(margin, current_y)
        textobject.setFont(FONT_NAME, 9) # Giáº£m cá»¡ chá»¯ cho ná»™i dung
        line_height = 12 # Chiá»u cao má»—i dÃ²ng text

        for ap_entry in ap_list_formatted:
            lines = ap_entry.strip().split('\n')
            entry_height_estimate = len(lines) * line_height + 10 # Æ¯á»›c tÃ­nh chiá»u cao cá»§a entry + khoáº£ng cÃ¡ch

            # Kiá»ƒm tra sang trang
            if textobject.getY() - entry_height_estimate < margin:
                c.drawText(textobject) # Váº½ text hiá»‡n táº¡i trÆ°á»›c khi sang trang
                c.showPage() # Táº¡o trang má»›i
                # Váº½ láº¡i header trang má»›i (tÃ¹y chá»n)
                c.setFont(FONT_NAME, 10)
                c.drawString(margin, height - margin + 10, f"NgÃ y táº¡o: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} (tiáº¿p theo)")
                c.line(margin, height-margin, width - margin, height-margin)
                current_y = height - margin - 20
                textobject = c.beginText(margin, current_y) # Báº¯t Ä‘áº§u text object má»›i
                textobject.setFont(FONT_NAME, 9)

            # Váº½ tá»«ng dÃ²ng cá»§a entry
            for line in lines:
                 # Xá»­ lÃ½ icon (Ä‘Æ¡n giáº£n hÃ³a, khÃ´ng dÃ¹ng icon phá»©c táº¡p trong PDF trá»« khi nhÃºng áº£nh)
                 clean_line = line.replace("ğŸ“¡ **", "SSID: ").replace("ğŸ” **", "BSSID: ").replace("ğŸ”’ **", "Báº£o máº­t: ").replace("ğŸ“¶ **", "KÃªnh/TÃ­n hiá»‡u:")
                 clean_line = clean_line.replace("`", "").replace("**", "") # XÃ³a markdown
                 if "ã€°ï¸ã€°ï¸ã€°ï¸" in clean_line or "----" in clean_line:
                     textobject.moveCursor(0, 5) # ThÃªm khoáº£ng trá»‘ng trÆ°á»›c dáº¥u phÃ¢n cÃ¡ch
                     textobject.textLine("-" * 70) # Váº½ Ä‘Æ°á»ng káº» ngang ngáº¯n
                     textobject.moveCursor(0, 5) # ThÃªm khoáº£ng trá»‘ng sau dáº¥u phÃ¢n cÃ¡ch
                 else:
                     textobject.textLine(clean_line)

            # KhÃ´ng cáº§n cáº­p nháº­t current_y thá»§ cÃ´ng, textobject.getY() sáº½ tá»± Ä‘á»™ng cáº­p nháº­t


        c.drawText(textobject) # Váº½ pháº§n text cÃ²n láº¡i
        c.save() # LÆ°u file PDF

        # Gá»­i file PDF lÃªn Telegram
        try:
            with open(pdf_filename, "rb") as pdf_file:
                await update.message.reply_document(
                    document=InputFile(pdf_file, filename=pdf_filename),
                    caption=f"Danh sÃ¡ch Access Points Ä‘Æ°á»£c táº¡o vÃ o lÃºc {datetime.now().strftime('%H:%M:%S %d/%m/%Y')}"
                )
            logger.info(f"ÄÃ£ gá»­i thÃ nh cÃ´ng file PDF: {pdf_filename}")
        except Exception as send_err:
             logger.error(f"Lá»—i khi gá»­i file PDF {pdf_filename}: {send_err}")
             await update.message.reply_text(f"âŒ ÄÃ£ táº¡o PDF nhÆ°ng lá»—i khi gá»­i: {send_err}")

    except Exception as e:
        logger.error(f"Lá»—i nghiÃªm trá»ng khi táº¡o PDF: {e}", exc_info=True) # Log traceback
        await update.message.reply_text(f"âŒ Lá»—i khÃ´ng mong muá»‘n khi táº¡o PDF: {e}")

    finally:
        # XÃ³a file PDF sau khi gá»­i (hoáº·c náº¿u cÃ³ lá»—i)
        if os.path.exists(pdf_filename):
            try:
                os.remove(pdf_filename)
                logger.info(f"ÄÃ£ xÃ³a file táº¡m: {pdf_filename}")
            except OSError as e:
                logger.error(f"KhÃ´ng thá»ƒ xÃ³a file táº¡m {pdf_filename}: {e}")

async def alert_command(update: Update, context: CallbackContext):
    """Láº¥y vÃ  gá»­i danh sÃ¡ch cáº£nh bÃ¡o."""
    await update.message.reply_text("ğŸ”” Äang kiá»ƒm tra danh sÃ¡ch cáº£nh bÃ¡o Kismet...")
    result = await get_alerts(limit=5) # Láº¥y 5 cáº£nh bÃ¡o gáº§n nháº¥t
    if result and isinstance(result, list) and result[0].startswith("âŒ"):
        await update.message.reply_text(result[0])
    elif not result:
         await update.message.reply_text("â„¹ï¸ KhÃ´ng cÃ³ cáº£nh bÃ¡o nÃ o.")
    else:
        result_text = "\n\n".join(result)
        if not result_text.strip():
            await update.message.reply_text("âœ… KhÃ´ng cÃ³ cáº£nh bÃ¡o nÃ o trong 5 cáº£nh bÃ¡o gáº§n nháº¥t.")
        else:
            for part in split_message(result_text):
                await update.message.reply_text(part, parse_mode="Markdown")


async def client_command(update: Update, context: CallbackContext):
    """Láº¥y danh sÃ¡ch client káº¿t ná»‘i vÃ o má»™t SSID."""
    if not context.args:
        await update.message.reply_text(
            "âš ï¸ Vui lÃ²ng nháº­p **SSID** cá»§a AP!\n"
            "VÃ­ dá»¥: `/client Tenda_123` hoáº·c `/client \"My Wifi Network\"` (dÃ¹ng ngoáº·c kÃ©p náº¿u SSID cÃ³ khoáº£ng tráº¯ng).",
            parse_mode="Markdown"
        )
        return

    ssid_filter = " ".join(context.args).strip()
    await update.message.reply_text(f"ğŸ‘¥ Äang tÃ¬m client káº¿t ná»‘i vÃ o AP cÃ³ SSID: **{ssid_filter}**...", parse_mode="Markdown")

    result = await get_clients_by_ap(ssid_filter) # result lÃ  list string

    if result and isinstance(result, list) and result[0].startswith("âŒ"):
        await update.message.reply_text(result[0], parse_mode="Markdown")
    elif not result:
         await update.message.reply_text(f"â„¹ï¸ KhÃ´ng tÃ¬m tháº¥y thÃ´ng tin client cho SSID: **{ssid_filter}**.", parse_mode="Markdown")
    else:
        result_text = "\n".join(result) # Ná»‘i báº±ng \n thay vÃ¬ \n\n
        for part in split_message(result_text):
            await update.message.reply_text(part, parse_mode="Markdown")


async def monitor_command(update: Update, context: CallbackContext):
    """Kiá»ƒm tra sá»± thay Ä‘á»•i SSID vÃ  bÃ¡o cÃ¡o RAP."""
    await update.message.reply_text("ğŸš¨ Äang kiá»ƒm tra thay Ä‘á»•i SSID (RAP Detection)...")
    rogue_aps = await monitor_ssid_changes() # Tráº£ vá» list cÃ¡c string hoáº·c list lá»—i

    if not rogue_aps:
        await update.message.reply_text("âœ… KhÃ´ng phÃ¡t hiá»‡n BSSID nÃ o thay Ä‘á»•i SSID báº¥t thÆ°á»ng.")
    elif isinstance(rogue_aps, list) and rogue_aps[0].startswith("âŒ"):
         await update.message.reply_text(f"Lá»—i khi giÃ¡m sÃ¡t: {rogue_aps[0]}")
    else:
        response = "âš ï¸ **Cáº£nh bÃ¡o thay Ä‘á»•i SSID:**\n\n" + "\n\n".join(rogue_aps)
        for part in split_message(response):
            await update.message.reply_text(part, parse_mode="Markdown")

async def summary_command(update: Update, context: CallbackContext):
    """Láº¥y vÃ  hiá»ƒn thá»‹ bÃ¡o cÃ¡o tÃ³m táº¯t Kismet."""
    await update.message.reply_text("ğŸ“Š Äang táº¡o bÃ¡o cÃ¡o tÃ³m táº¯t Kismet...")

    summary_data = await get_summary_data()

    # --- Xá»­ lÃ½ lá»—i náº¿u cÃ³ ---
    if summary_data["errors"]:
        error_message = "âš ï¸ ÄÃ£ xáº£y ra lá»—i khi láº¥y dá»¯ liá»‡u tÃ³m táº¯t:\n- " + "\n- ".join(summary_data["errors"])
        # Váº«n tiáº¿p tá»¥c hiá»ƒn thá»‹ pháº§n dá»¯ liá»‡u láº¥y Ä‘Æ°á»£c náº¿u cÃ³
        await update.message.reply_text(error_message)

    # --- Format Tin nháº¯n Káº¿t quáº£ ---
    summary_text = "ğŸ“Š **BÃ¡o cÃ¡o TÃ³m táº¯t Kismet** ğŸ“Š\n"
    summary_text += "------------------------------------\n"
    summary_text += f"ğŸ“¡ **Tá»•ng sá»‘ Access Points:** `{summary_data['ap_count']}`\n"
    summary_text += f"ğŸ“± **Tá»•ng sá»‘ Clients Wi-Fi:** `{summary_data['client_count']}`\n"
    summary_text += f"ğŸ”” **Cáº£nh bÃ¡o má»›i (24h):** `{summary_data['new_alert_count']}`\n"
    summary_text += "------------------------------------\n\n"

    if summary_data["strongest_ap"]:
        ap = summary_data['strongest_ap']
        signal = summary_data['max_ap_signal']
        summary_text += (f"ğŸ‘‘ **AP TÃ­n hiá»‡u Máº¡nh nháº¥t:**\n"
                         f"   SSID: `{ap['ssid']}`\n"
                         f"   BSSID: `{ap['bssid'].upper()}`\n"
                         f"   TÃ­n hiá»‡u: `{signal} dBm`\n\n")
    else:
        summary_text += "ğŸ‘‘ **AP TÃ­n hiá»‡u Máº¡nh nháº¥t:** `(KhÃ´ng cÃ³ dá»¯ liá»‡u)`\n\n"

    if summary_data["strongest_client"]:
        client = summary_data['strongest_client']
        signal = summary_data['max_client_signal']
        summary_text += (f"ğŸ’ª **Client TÃ­n hiá»‡u Máº¡nh nháº¥t:**\n"
                         f"   MAC: `{client['mac'].upper()}`\n"
                         f"   TÃ­n hiá»‡u: `{signal} dBm`\n")
    else:
        summary_text += "ğŸ’ª **Client TÃ­n hiá»‡u Máº¡nh nháº¥t:** `(KhÃ´ng cÃ³ dá»¯ liá»‡u)`\n"

    # --- Gá»­i Tin nháº¯n ---
    # Gá»­i khÃ´ng cÃ³ bÃ n phÃ­m reply cho lá»‡nh nÃ y
    await update.message.reply_text(summary_text, parse_mode="Markdown", reply_markup=None)


# --- Error Handler ---

async def error_handler(update: object, context: CallbackContext):
    """Log lá»—i vÃ  thÃ´ng bÃ¡o cho ngÆ°á»i dÃ¹ng."""
    logger.error(f"Exception while handling an update: {context.error}", exc_info=context.error)

    # Cá»‘ gáº¯ng thÃ´ng bÃ¡o lá»—i cho ngÆ°á»i dÃ¹ng náº¿u cÃ³ thá»ƒ
    if isinstance(update, Update) and update.effective_message:
        try:
            await update.effective_message.reply_text("âŒ Ráº¥t tiáº¿c, Ä‘Ã£ cÃ³ lá»—i xáº£y ra trong quÃ¡ trÃ¬nh xá»­ lÃ½ yÃªu cáº§u cá»§a báº¡n. Vui lÃ²ng thá»­ láº¡i sau.")
        except Exception as e:
            logger.error(f"KhÃ´ng thá»ƒ gá»­i thÃ´ng bÃ¡o lá»—i cho ngÆ°á»i dÃ¹ng: {e}")

# --- Setup and Run ---

def setup_handlers(application):
    """ÄÄƒng kÃ½ táº¥t cáº£ cÃ¡c command handler."""
    handlers = [
        CommandHandler("start", start),
        CommandHandler("help", help_command),
        CommandHandler("ap", ap_command),
        CommandHandler("summary", summary_command),
        CommandHandler("alert", alert_command),
        CommandHandler("client", client_command),
        CommandHandler("monitor", monitor_command),
        CommandHandler("appdf", appdf_command),
         # ThÃªm MessageHandler Ä‘á»ƒ báº¯t cÃ¡c lá»‡nh khÃ´ng há»£p lá»‡ hoáº·c tin nháº¯n thÆ°á»ng
         # Tráº£ vá» help náº¿u ngÆ°á»i dÃ¹ng gá»­i tin nháº¯n khÃ´ng pháº£i lá»‡nh
         MessageHandler(filters.TEXT & ~filters.COMMAND, help_command)
    ]
    for handler in handlers:
        application.add_handler(handler)

    # ÄÄƒng kÃ½ error handler
    application.add_error_handler(error_handler)
    logger.info("ÄÃ£ Ä‘Äƒng kÃ½ cÃ¡c handlers.")

def main():
    """Khá»Ÿi cháº¡y bot Telegram."""
    logger.info("Báº¯t Ä‘áº§u khá»Ÿi táº¡o bot...")
    try:
        application = Application.builder().token(TOKEN).build()
        setup_handlers(application)
        logger.info("Bot Ä‘ang báº¯t Ä‘áº§u cháº¡y...")
        application.run_polling()
    except Exception as e:
        logger.critical(f"Lá»—i nghiÃªm trá»ng khi khá»Ÿi táº¡o hoáº·c cháº¡y bot: {e}", exc_info=True)

if __name__ == "__main__":
    main()
