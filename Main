import logging
import requests
from requests.auth import HTTPBasicAuth
from telegram import Update, InputFile
from telegram.ext import Application, CommandHandler, CallbackContext
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.pdfbase import pdfmetrics
import os

# ğŸ”¹ ThÃ´ng tin Bot Telegram
TOKEN = "8074321892:AAF6glPFFhVkWdS_FWVBYaMN4MkE8jsEjmY"

# ğŸ”¹ ThÃ´ng tin Kismet API
KISMET_URL = "http://localhost:2501"
KISMET_USERNAME = "kali"
KISMET_PASSWORD = "kali"

# Cáº¥u hÃ¬nh logging
logging.basicConfig(
    filename="bot.log",
    format="%(asctime)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ğŸ“¡ HÃ m láº¥y danh sÃ¡ch táº¥t cáº£ AP tá»« Kismet
def fetch_kismet_data(endpoint):
    try:
        url = f"{KISMET_URL}{endpoint}"
        response = requests.get(url, auth=HTTPBasicAuth(KISMET_USERNAME, KISMET_PASSWORD))
        response.raise_for_status()

        if "application/json" not in response.headers.get("Content-Type", ""):
            return None, "âŒ Dá»¯ liá»‡u khÃ´ng há»£p lá»‡!"

        return response.json(), None

    except requests.exceptions.RequestException as e:
        return None, f"âŒ Lá»—i káº¿t ná»‘i Kismet: {e}"

async def get_all_ap():
    data, error = fetch_kismet_data("/phy/phy80211/ssids/views/ssids.json")
    if error:
        return [error]

    ap_list = []
    for ap in data:
        ssid = ap.get("dot11.ssidgroup.ssid", "Unknown")
        bssid_list = ap.get("dot11.ssidgroup.advertising_devices", [])
        bssid = bssid_list[0] if bssid_list else "Unknown"
        encryption = "Open" if ap.get("dot11.ssidgroup.crypt_set", 1) == 0 else "Encrypted"

        ap_list.append(f"SSID: {ssid}\nBSSID: {bssid}\nBáº£o máº­t: {encryption}\n{'-'*40}")

    return ap_list if ap_list else ["âœ… KhÃ´ng tÃ¬m tháº¥y AP nÃ o!"]

# ğŸ“¡ HÃ m láº¥y danh sÃ¡ch cáº£nh bÃ¡o tá»« Kismet (Chá»‰ láº¥y 5 cáº£nh bÃ¡o gáº§n nháº¥t)
async def get_alerts():
    data, error = fetch_kismet_data("/alerts/all_alerts.json")
    if error:
        return [error]

    if not data or not isinstance(data, list):
        return ["âœ… KhÃ´ng cÃ³ cáº£nh bÃ¡o nÃ o tá»« Kismet!"]

    latest_alerts = data[:5]  # Láº¥y 5 cáº£nh bÃ¡o gáº§n nháº¥t
    alert_list = []
    for alert in latest_alerts:
        alert_type = alert.get("alert_key", "Unknown")
        alert_msg = alert.get("alert_text", "KhÃ´ng cÃ³ mÃ´ táº£")
        timestamp = alert.get("timestamp", "Unknown")

        alert_list.append(f"ğŸ”” {alert_type}\nğŸ“Œ {alert_msg}\nğŸ•’ {timestamp}\n{'-'*40}")

    return alert_list

# ğŸ“¡ Lá»‡nh /appdf Ä‘á»ƒ xuáº¥t danh sÃ¡ch AP thÃ nh file PDF
async def appdf_command(update: Update, context: CallbackContext):
    await update.message.reply_text("ğŸ“„ Äang táº¡o file PDF...")

    ap_list = await get_all_ap()
    if not ap_list:
        await update.message.reply_text("âš ï¸ KhÃ´ng cÃ³ dá»¯ liá»‡u AP Ä‘á»ƒ xuáº¥t PDF.")
        return

    pdf_filename = "access_points.pdf"
    
    try:
        pdfmetrics.registerFont(TTFont("DejaVu", "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"))
        c = canvas.Canvas(pdf_filename, pagesize=letter)
        width, height = letter
        c.setFont("DejaVu", 16)
        c.drawCentredString(width / 2, height - 50, "ğŸ“Œ Danh sÃ¡ch Access Point")

        text = c.beginText(50, height - 80)
        text.setFont("DejaVu", 12)

        for ap in ap_list:
            for line in ap.split("\n"):
                text.textLine(line)
            text.textLine(" ")

        c.drawText(text)
        c.save()

        # Gá»­i file PDF lÃªn Telegram
        with open(pdf_filename, "rb") as pdf_file:
            await update.message.reply_document(document=InputFile(pdf_file, filename=pdf_filename))
        
    except Exception as e:
        await update.message.reply_text(f"âŒ Lá»—i khi táº¡o PDF: {e}")
    
    finally:
        if os.path.exists(pdf_filename):
            os.remove(pdf_filename)

# ğŸ“¡ Lá»‡nh /alert Ä‘á»ƒ láº¥y danh sÃ¡ch cáº£nh bÃ¡o tá»« Kismet
async def alert_command(update: Update, context: CallbackContext):
    await update.message.reply_text("ğŸ” Äang kiá»ƒm tra danh sÃ¡ch cáº£nh bÃ¡o tá»« Kismet...")
    result = await get_alerts()
    result_text = "\n\n".join(result)

    for part in split_message(result_text):
        await update.message.reply_text(part)

# Chia nhá» tin nháº¯n náº¿u vÆ°á»£t quÃ¡ giá»›i háº¡n Telegram (4096 kÃ½ tá»±)
def split_message(text, chunk_size=4000):
    for i in range(0, len(text), chunk_size):
        yield text[i:i + chunk_size]

# ğŸ“¡ Lá»‡nh /ap Ä‘á»ƒ láº¥y danh sÃ¡ch AP vÃ  gá»­i lÃªn Telegram
async def ap_command(update: Update, context: CallbackContext):
    await update.message.reply_text("ğŸ” Äang kiá»ƒm tra danh sÃ¡ch AP...")
    result = await get_all_ap()
    result_text = "\n\n".join(result)

    for part in split_message(result_text):
        await update.message.reply_text(part)

# ğŸ“¡ HÃ m láº¥y danh sÃ¡ch client Ä‘ang káº¿t ná»‘i vÃ o má»™t AP tá»« Kismet
async def get_clients_by_ap(ssid_filter):
    try:
        url = f"{KISMET_URL}/devices/views/all/devices.json"
        response = requests.get(url, auth=HTTPBasicAuth(KISMET_USERNAME, KISMET_PASSWORD))

        if response.status_code == 200:
            data = response.json()
            if not isinstance(data, list):
                return ["âŒ Dá»¯ liá»‡u tráº£ vá» khÃ´ng há»£p lá»‡!"]

            client_list = []
            for device in data:
                # Chá»‰ láº¥y cÃ¡c thiáº¿t bá»‹ lÃ  Wi-Fi Client
                if device.get("kismet.device.base.type") == "Wi-Fi Client":
                    # Láº¥y danh sÃ¡ch SSID mÃ  thiáº¿t bá»‹ Ä‘Ã£ káº¿t ná»‘i vÃ o
                    ssid_list = device.get("dot11.device.last_bssid", [])
                    
                    # Kiá»ƒm tra náº¿u SSID client Ä‘ang káº¿t ná»‘i trÃ¹ng vá»›i SSID cáº§n tÃ¬m
                    if isinstance(ssid_list, list) and ssid_filter in ssid_list:
                        mac_address = device.get("kismet.device.base.macaddr", "Unknown")
                        manufacturer = device.get("kismet.device.base.manuf", "Unknown")
                        signal_strength = device.get("kismet.common.signal.last_signal", "N/A")

                        client_list.append(
                            f"ğŸ–¥ **MAC**: {mac_address}\n"
                            f"ğŸ­ **HÃ£ng**: {manufacturer}\n"
                            f"ğŸ“¶ **TÃ­n hiá»‡u**: {signal_strength} dBm\n"
                            f"{'-'*40}"
                        )

            return client_list if client_list else [f"âœ… KhÃ´ng cÃ³ client nÃ o káº¿t ná»‘i vÃ o AP **{ssid_filter}**!"]

        elif response.status_code == 401:
            return ["âŒ Lá»—i xÃ¡c thá»±c! Vui lÃ²ng kiá»ƒm tra username & password Kismet."]
        
        else:
            return [f"âŒ Lá»—i káº¿t ná»‘i Kismet: {response.status_code}"]

    except Exception as e:
        return [f"âš ï¸ Lá»—i khi láº¥y dá»¯ liá»‡u tá»« Kismet: {e}"]


# ğŸ“¡ Lá»‡nh /client Ä‘á»ƒ kiá»ƒm tra client káº¿t ná»‘i vÃ o AP
async def client_command(update: Update, context: CallbackContext):
    if not context.args:
        await update.message.reply_text("âš ï¸ Vui lÃ²ng nháº­p **SSID** cá»§a AP!\nVÃ­ dá»¥: `/client abc`", parse_mode="Markdown")
        return

    ssid_filter = " ".join(context.args)  # Láº¥y tÃªn SSID tá»« lá»‡nh
    await update.message.reply_text(f"ğŸ” Äang kiá»ƒm tra client káº¿t ná»‘i vÃ o AP: **{ssid_filter}**...", parse_mode="Markdown")

    result = await get_clients_by_ap(ssid_filter)
    result_text = "\n\n".join(result)

    # Chia nhá» tin nháº¯n náº¿u quÃ¡ dÃ i
    for part in split_message(result_text):
        await update.message.reply_text(part, parse_mode="Markdown")

# Lá»‡nh /start
async def start(update: Update, context: CallbackContext):
    await update.message.reply_text("Xin chÃ o! GÃµ /help Ä‘á»ƒ xem danh sÃ¡ch lá»‡nh.")

# Lá»‡nh /help
async def help_command(update: Update, context: CallbackContext):
    help_text = (
        "ğŸ“Œ Danh sÃ¡ch lá»‡nh cÃ³ sáºµn:\n"
        "/start - Báº¯t Ä‘áº§u bot\n"
        "/help - Hiá»ƒn thá»‹ danh sÃ¡ch lá»‡nh\n"
        "/ap - Láº¥y danh sÃ¡ch Access Point tá»« Kismet\n"
        "/appdf - Xuáº¥t danh sÃ¡ch Access Point thÃ nh file PDF\n"
        "/alert - Xem cáº£nh bÃ¡o Kismet\n"
        "/client_nameWiFi - Xem cÃ¡c client Ä‘ang káº¿t ná»‘i"
    )
    await update.message.reply_text(help_text)

# Xá»­ lÃ½ lá»—i chung
async def error_handler(update: object, context: CallbackContext):
    logger.error(f"Lá»—i xáº£y ra: {context.error}")
    if update and update.message:
        await update.message.reply_text("âŒ CÃ³ lá»—i xáº£y ra! Vui lÃ²ng thá»­ láº¡i sau.")

# Cáº¥u hÃ¬nh cÃ¡c handler
def setup_handlers(application):
    handlers = [
        CommandHandler("start", start),
        CommandHandler("help", help_command),
        CommandHandler("ap", ap_command),
        CommandHandler("appdf", appdf_command),
        CommandHandler("alert", alert_command),
        CommandHandler("client", client_command)
    ]
    for handler in handlers:
        application.add_handler(handler)

    # ThÃªm xá»­ lÃ½ lá»—i
    application.add_error_handler(error_handler)

# Khá»Ÿi cháº¡y bot
def main():
    application = Application.builder().token(TOKEN).build()
    setup_handlers(application)
    application.run_polling()

if __name__ == "__main__":
    main()
